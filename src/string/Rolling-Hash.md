---
title: ローリングハッシュ法 (Rabin-Karp法)
---

各文字を数字にして，$B$進法と解釈して数値にします

**比較を定数で行える文字列**，といった扱い方ができます

ローリングハッシュ法を使った文字列検索がRabin-Karp法です

modを$M$，文字列の長さを$N$とし，$M$は文字種より十分大きいとします．$k$を $(B, M)$ のペアの数とします

通常はハッシュが一致したら実際の値が一致するか調べるんですが，競プロでは調べて得するケースはあまりないと思います

# 衝突しやすいmodに注意

[hosさんの解説](http://hos.ac/blog/#blog0003){:target="_blank"}<!--_--> がとてもわかりやすいです

$M$が$2^64$の約数では危ない．たった4096文字のhackがある

$M$ に**素数**を用いることで衝突する確率が $N/M$ ぐらいになる (多項式と根の数が関係しています)．$B$ は一様ランダムに選べば何でもよし．0はダメだと思うけど

実際は衝突する確率を小さくするために $(B, M)$ の組み合わせを複数用意します

別に素数という制約がある $M$ をたくさん用意する必要はないと思うので $B$ をいくつか用意するというものでいいと思います

現実的に $10^6$ 回程度の比較，$N \approx 10^6, M \approx 10^9$ だとすると，$B$を3つ用意すれば成功確率 `99.90%`となり十分です ([計算に用いたファイル - gist](https://gist.github.com/LumaKernel/709d69a5788c1bf333f5bb7df3777c95){:target="_blank"}<!--_-->)

# 実装

一応ライブラリとして書いてみました

// @ HashString with rolling-hash

## 使い方

実際の文字列の情報は (長さ含め) 保持しません

* コンストラクタ `mystring( <string-like> )` : イテレータや`string`, `vector` などから `mystring` に変換できます
* `push_front(T c)` : 1文字シフトして0文字目に文字`c`を挿入
* `shift(ll n = 1)` : n文字シフトする．負でも可
* `changeAt(ll x, T from, T to)` : x文字目をfromからtoに変える (fromは自分で用意する)
* `str[ll x] -= `, `str[ll x] += ` : x文字目から引いたり足したり．負でも可

`unordered_set` や `unordered_map` の `Key` として用いることができます

もとの文字列保持しててもいいなと思ったんですが，コピーも $O(1)$ にしようみたいなどうでもいいことのために

すべて $O(k\log M)$ 時間, 比較は $O(k)$

# 検証

した (主張)．OJにはまだsubmitしていない TODO

# 参考

* 蟻本

