{"FastZetaTransform":"// a'[i] = sum(j は i を含む, a[j])\ntemplate < class T >\nvoid zeta(vector< T > &a,\n          function< T(T, T) > const &op = [](T a, T b) { return a + b; }) {\n  int n = a.size();\n  for(int i = 0; i < n; i++)\n    for(int b = 0; b < (1 << n); b++)\n      if(!(b & (1 << i))) a[b] = op(a[b], a[b | (1 << i)]);\n}","FastMoebiusTransform":"// zetaの逆操作\ntemplate < class T >\nvoid moebius(vector< T > &a,\n             function< T(T, T) > const &op = [](T a, T b) { return a - b; }) {\n  int n = a.size();\n  for(int i = 0; i < n; i++)\n    for(int b = 0; b < (1 << n); b++)\n      if(b & (1 << i)) a[b] = op(a[b], a[b | (1 << i)]);\n}","Garner Library":"/// --- Garner Library {{{ ///\nll garner(vector< int > n, vector< int > mods, ll mod) {\n  n.emplace_back(0);\n  mods.emplace_back(mod);\n  vector< ll > coeffs(n.size(), 1); // v_i の係数\n  // v_i の項より後ろの項の和,答え mod mods[i]\n  vector< ll > constants(n.size(), 0);\n  for(size_t i = 0; i < n.size(); i++) {\n    // coeffs[i] * v_i + constants[i] == n[i] (mod mods[i]) を解く\n    ll v = ll(n[i] - constants[i]) * modinv(coeffs[i], mods[i]) % mods[i];\n    if(v < 0) v += mods[i];\n    for(size_t j = i + 1; j < n.size(); j++) {\n      // coeffs[j] is (mod j)\n      (constants[j] += coeffs[j] * v) %= mods[j];\n      (coeffs[j] *= mods[i]) %= mods[j];\n    }\n  }\n  return constants.back();\n}\n/// }}}--- ///","Hu-Tucker Algorithm Library":"// calculate value of optimal alphabetic binary search tree\n// if you want to construct? you can do it!\n/// --- Hu-Tucker Algorithm Library {{{ ///\ntemplate < class Heap, class T = ll >\nT HuTucker(const vector< T > &w) {\n  using P = pair< T, int >; // value, index\n  int n = w.size();\n  function< T(Heap * &a) > calc = [](Heap *&a) { ////\n    return a->val.first + second(a)->val.first;\n  };\n  vector< int > rig(n), lef(n);\n  vector< int > removed(n), used(n);\n  vector< Heap * > dat(n);\n  function< bool(int) > isAvailable = [&](int idx) {\n    if(idx < 0) return true;\n    if(idx >= n) idx -= n; /////\n    return !used[idx];\n  };\n  function< void(Heap *&, int, int) > check = [&](Heap *&top, int gid,\n                                                  int idx) {\n    if(idx < 0) return;\n    if(idx < n) {\n      used[idx] = 1;\n      if(lef[gid] >= 0) {\n        top = meld(top, dat[lef[gid]]);\n        removed[lef[gid]] = 1;\n        lef[gid] = lef[lef[gid]];\n        if(lef[gid] >= 0) rig[lef[gid]] = gid; ///\n      }\n    } else {\n      used[idx - n] = 1;\n      if(rig[gid] < n - 1) {\n        top = meld(top, dat[rig[gid]]);\n        removed[rig[gid]] = 1;\n        rig[gid] = rig[rig[gid]];\n        if(rig[gid] < n - 1) lef[rig[gid]] = gid; ///\n      }\n    }\n  };\n  priority_queue< P, vector< P >, greater< P > > pq; ///\n  for(int i = 0; i < n - 1; i++) {\n    auto *a = new Heap(P(w[i], i)), *b = new Heap(P(w[i + 1], i + 1 + n));\n    dat[i] = meld(a, b);\n    pq.emplace(calc(dat[i]), i); ///\n    lef[i] = i - 1;\n    rig[i] = i + 1;\n  }\n  ll ans = 0;\n  while(pq.size()) {\n    int i = pq.top().second;\n    auto top = dat[i];\n    pq.pop();\n    if(removed[i]) continue;\n    P p0 = top->val;\n    P p1 = second(top)->val;\n    pop(top);\n    pop(top);\n    bool c0 = isAvailable(p0.second);\n    bool c1 = isAvailable(p1.second);\n    if(!c0 || !c1) {\n      if(c0) push(top, p0);\n      if(c1) push(top, p1);\n      dat[i] = top;\n      if(top != nullptr && top->l != nullptr) {\n        pq.emplace(calc(top), i); ///\n      }\n      continue;\n    }\n    T nval = p0.first + p1.first;\n    ans += nval;\n    check(top, i, p0.second);\n    check(top, i, p1.second);\n    if(top != nullptr) {\n      push(top, P(nval, -1));\n      dat[i] = top;\n      pq.emplace(calc(top), i); ///\n    }\n  }\n  return ans;\n}\n/// }}}--- ///\n\n// usage :\n// HuTucker< SkewHeap< pair<ll, int> > >(w)","Kitamasa Library":"template < class T >\nvector< T > kitamasa(const vector< T > &c, const vector< T > &u,\n                     const vector< T > &v) {\n  int k = c.size();\n  vector< T > r(2 * k - 1);\n  for(int i = 0; i < k; i++)\n    for(int j = 0; j < k; j++) r[i + j] += u[i] * v[j];\n  for(int i = 2 * k - 2; i >= k; i--)\n    for(int j = 0; j < k; j++) r[i - k + j] += r[i] * c[j];\n  r.resize(k);\n  return r;\n}","MoTreeVertex Library":"// MoTreeVertex(N, JUST Q, double k)\n// favored : k = 2\n// 1: addEdge\n// 2: prebuild\n// 3: insert\n// 4: build\n/// --- MoTreeVertex Library {{{ ///\n\nstruct MoTreeVertex {\n  const int n, logn, m;\n  const int width;\n  int q = 0;\n  vector< vector< int > > par;\n  vector< int > dep;\n  vector< int > in, vs;\n  vector< vector< int > > g;\n  vector< int8_t > flag;\n  vector< int > le, ri, lcas, order;\n  int nl = 0, nr = 0;\n  int log(int x) {\n    int h = 1;\n    while((1 << h) < x) h++;\n    return h;\n  }\n  MoTreeVertex(int n, int q, double k = 1)\n      : n(n),\n        logn(log(n)),\n        m(2 * n - 1),\n        width(int(k* m / sqrt(q) + 1.0)),\n        q(q),\n        par(logn, vector< int >(n, -1)),\n        dep(n),\n        in(n),\n        g(n),\n        flag(n),\n        le(q),\n        ri(q),\n        lcas(q),\n        order(q) {\n    vs.reserve(m);\n  }\n  inline void addEdge(int u, int v) {\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n  inline void prebuild() {\n    dfs(0, -1, 0);\n    for(int k = 1; k < logn; k++)\n      for(int i = 0; i < n; i++) {\n        int p = par[k - 1][i];\n        if(p == -1) continue;\n        par[k][i] = par[k - 1][p];\n      }\n  }\n  void dfs(int i, int p, int d) {\n    dep[i] = d;\n    par[0][i] = p;\n    in[i] = vs.size();\n    vs.emplace_back(i);\n    for(int j : g[i])\n      if(j != p) {\n        dfs(j, i, d + 1);\n        vs.emplace_back(j);\n      }\n  }\n  inline int lca(int u, int v) {\n    if(dep[u] > dep[v]) swap(u, v);\n    for(int k = logn - 1; k >= 0; k--) {\n      int nv = par[k][v];\n      if(nv != -1 && dep[nv] >= dep[u]) v = nv;\n    }\n    if(u == v) return u;\n    for(int k = logn - 1; k >= 0; k--) {\n      int nu = par[k][u], nv = par[k][v];\n      if(nu != nv) u = nu, v = nv;\n    }\n    return par[0][u];\n  }\n  inline void insert(int u, int v) {\n    if(in[u] > in[v]) swap(u, v);\n    le[q] = in[u] + 1;\n    ri[q] = in[v] + 1;\n    lcas[q] = lca(u, v);\n    order[q] = q;\n    q++;\n  }\n  inline void build() {\n    sort(begin(order), begin(order) + q, [&](int a, int b) {\n      const int ab = le[a] / width, bb = le[b] / width;\n      return ab != bb ? ab < bb : ab & 1 ? ri[a] < ri[b] : ri[b] < ri[a];\n    });\n    nl = nr = le[order[0]];\n    for(int i = 0; i < q; i++) {\n      if(i > 0) rem(lcas[order[i - 1]]);\n      const int id = order[i];\n      while(nl > le[id]) flip(vs[--nl]);\n      while(nr < ri[id]) flip(vs[nr++]);\n      while(nl < le[id]) flip(vs[nl++]);\n      while(nr > ri[id]) flip(vs[--nr]);\n      add(lcas[id]);\n      next(id);\n    }\n  }\n  inline void flip(int i) {\n    if(flag[i] ^= 1)\n      add(i);\n    else\n      rem(i);\n  }\n  inline void next(int id);\n  inline void add(int i);\n  inline void rem(int i);\n};\n\n/// }}}--- ///\n\ninline void MoTreeVertex::next(int id) {}\ninline void MoTreeVertex::add(int i) {}\ninline void MoTreeVertex::rem(int i) {}","Mo Library":"// Mo(N, JUST Q, double k)\n// favored : k = 2\n// 1: insert\n// 2: build\n/// --- Mo Library {{{ ///\n\nstruct Mo {\n  const int width;\n  int q = 0;\n  vector< int > le, ri, order;\n  int nl = 0, nr = 0;\n  Mo(int n, int q, double k = 1)\n      : width(int(k* n / sqrt(q) + 1.0)), le(q), ri(q), order(q) {}\n  inline void insert(int l, int r) {\n    le[q] = l;\n    ri[q] = r;\n    order[q] = q;\n    q++;\n  }\n  inline void build() {\n    sort(begin(order), begin(order) + q, [&](int a, int b) {\n      const int ab = le[a] / width, bb = le[b] / width;\n      return ab != bb ? ab < bb : ab & 1 ? ri[a] < ri[b] : ri[b] < ri[a];\n    });\n    nl = nr = le[order[0]];\n    for(int i = 0; i < q; i++) {\n      const int id = order[i];\n      while(nl > le[id]) add(--nl);\n      while(nl < le[id]) rem(nl++);\n      while(nr < ri[id]) add(nr++);\n      while(nr > ri[id]) rem(--nr);\n      next(id);\n    }\n  }\n  inline void next(int i);\n  inline void add(int i);\n  inline void rem(int i);\n};\n\n/// }}}--- ///\n\ninline void Mo::next(int i) {}\ninline void Mo::add(int i) {}\ninline void Mo::rem(int i) {}","Mo3D Library":"// Mo3D(N, JUST Q, double k)\n// favored : k = 6\n// 1: insert\n// 2: build\n/// --- Mo3D Library {{{ ///\n\nstruct Mo3D {\n  const int width;\n  int q = 0;\n  vector< int > le, ri, idx, order;\n  int nl = 0, nr = 0, time = -1;\n  Mo3D(int n, int q, double k = 1)\n      : width(int(k* pow(max(n, q), 2.0 / 3.0) + 1.0)),\n        le(q),\n        ri(q),\n        idx(q),\n        order(q) {}\n  inline void insert(int t, int l, int r) {\n    idx[q] = t;\n    le[q] = l;\n    ri[q] = r;\n    order[q] = q;\n    q++;\n  }\n  inline void build() {\n    sort(begin(order), begin(order) + q, [&](int a, int b) {\n      const int al = le[a] / width, bl = le[b] / width;\n      const int ar = ri[a] / width, br = ri[b] / width;\n      return al != bl ? al < bl : ar != br ? ar < br : idx[a] < idx[b];\n    });\n    nl = nr = le[order[0]];\n    for(int i = 0; i < q; i++) {\n      const int id = order[i];\n      while(time < idx[id]) addQuery(++time);\n      while(time > idx[id]) remQuery(time--);\n      while(nl > le[id]) add(--nl);\n      while(nr < ri[id]) add(nr++);\n      while(nl < le[id]) rem(nl++);\n      while(nr > ri[id]) rem(--nr);\n      next(id);\n    }\n  }\n  inline void next(int i);\n  inline void addQuery(int i);\n  inline void remQuery(int i);\n  inline void add(int i);\n  inline void rem(int i);\n};\n\n/// }}}--- ///\n\n// i is sequential\n// idx[i] is absolute\ninline void Mo3D::next(int i) {}\ninline void Mo3D::addQuery(int i) {}\ninline void Mo3D::remQuery(int i) {}\ninline void Mo3D::add(int i) {}\ninline void Mo3D::rem(int i) {}","MoEx UF example":"const int N = 1e5;\n\nint par[N * 2];\nint col = 1;\nint used[N * 2];\nint ans[N];\nusing P = pair< int, int >;\nvector< P > history;\n\nvoid reset(int i) {\n  if(used[i] != col) used[i] = col, par[i] = -1;\n}\nint find(int a) {\n  reset(a);\n  return par[a] < 0 ? a : find(par[a]);\n}\nbool same(int a, int b) { return find(a) == find(b); }\nvoid unite(int a, int b) {\n  a = find(a), b = find(b);\n  if(a == b) return;\n  if(par[a] < par[b]) swap(a, b);\n  history.emplace_back(b, par[b]);\n  history.emplace_back(a, par[a]);\n  par[b] += par[a];\n  par[a] = b;\n}\n\ninline void MoEx::next(int id) { ans[id]; /* */ }\ninline void MoEx::init() {\n  //\n  history.clear();\n  col++;\n}\ninline void MoEx::snapshot() {\n  oldNow = now;\n  history.clear();\n}\ninline void MoEx::rollback() {\n  now = oldNow;\n  while(history.size()) {\n    int i, x;\n    tie(i, x) = history.back();\n    par[i] = x;\n    history.pop_back();\n  }\n}\ninline void MoEx::add(int i) {\n  unite(a[i] + N, b[i]);\n  unite(a[i], b[i] + N);\n  //\n}","Mo with Persistent Data Structure Library":"// MoEx(N, JUST Q, double k)\n// favored : k = 2\n// 1: insert\n// 2: build\n/// --- Mo with Persistent Data Structure Library {{{ ///\n\nstruct MoEx {\n  const int width;\n  int q = 0;\n  vector< int > le, ri, order;\n  MoEx(int n, int q, double k = 1)\n      : width(int(k* n / sqrt(q) + 1.0)), le(q), ri(q), order(q) {}\n  inline void insert(int l, int r) {\n    le[q] = l;\n    ri[q] = r;\n    order[q] = q;\n    q++;\n  }\n  inline void build() {\n    for(int i = 0; i < q; i++)\n      if(ri[i] - le[i] < width) {\n        init();\n        for(int j = le[i]; j < ri[i]; j++) add(j);\n        next(i);\n      }\n    sort(begin(order), begin(order) + q, [&](int a, int b) {\n      const int ab = le[a] / width, bb = le[b] / width;\n      return ab != bb ? ab < bb : ri[a] < ri[b];\n    });\n    int last = -1;\n    int nr;\n    for(int i = 0; i < q; i++) {\n      int id = order[i];\n      if(ri[id] - le[id] < width) continue;\n      int b = le[id] / width;\n      if(last != b) init(), nr = (b + 1) * width;\n      last = b;\n      while(nr < ri[id]) add(nr++);\n      snapshot();\n      for(int j = (b + 1) * width - 1; j >= le[id]; j--) add(j);\n      next(id);\n      rollback();\n    }\n  }\n  inline void next(int id);\n  inline void init();\n  inline void snapshot();\n  inline void rollback();\n  inline void add(int i);\n};\n\n/// }}}--- ///\n\ninline void MoEx::next(int id) {}\ninline void MoEx::init() {}\ninline void MoEx::snapshot() {}\ninline void MoEx::rollback() {}\ninline void MoEx::add(int i) {}","RBST Sequence Library":"/// --- RBST Sequence Library {{{ ///\n\ntemplate < class Monoid, class M_act >\nstruct RBSTSeq {\nprivate:\n  using u32 = uint32_t;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  RBSTSeq *l = nullptr, *r = nullptr;\n  X val;\n  X accum = Monoid::identity();\n  M lazy = M_act::identity();\n  bool rev = false;\n  int sz = 1;\n  // call after touch its child\n  // a is not nullptr and is evaled, its child is proped\n  friend RBSTSeq *prop(RBSTSeq *a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    a->accum =\n        Monoid::op(Monoid::op(Accumulated(a->l), a->val), Accumulated(a->r));\n    return a;\n  }\n  // call before use val, accum\n  friend void eval(RBSTSeq *a) {\n    if(a->lazy != M_act::identity()) {\n      a->val = M_act::actInto(a->lazy, -1, 1, a->val);\n      a->accum = M_act::actInto(a->lazy, -1, a->sz, a->accum);\n      if(a->l != nullptr) a->l->lazy = M_act::op(a->lazy, a->l->lazy);\n      if(a->r != nullptr) a->r->lazy = M_act::op(a->lazy, a->r->lazy);\n      a->lazy = M_act::identity();\n    }\n    if(a->rev) {\n      swap(a->l, a->r);\n      if(a->l != nullptr) a->l->rev ^= 1;\n      if(a->r != nullptr) a->r->rev ^= 1;\n      a->rev = false;\n    }\n  }\n  friend X Accumulated(RBSTSeq *a) {\n    return a == nullptr ? Monoid::identity() : (eval(a), a->accum);\n  }\n  /// --- XorShift128 {{{ ///\n  struct XorShift128 {\n    using u32 = uint32_t;\n    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128(u32 seed = 0) { z ^= seed; }\n    u32 operator()() {\n      u32 t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n  /// }}}--- ///\npublic:\n  RBSTSeq(X val = Monoid::identity()) : val(val) {}\n  friend RBSTSeq *merge(RBSTSeq *a, RBSTSeq *b) {\n    static XorShift128 xs(__LINE__ * 3 + 5);\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    eval(a);\n    eval(b);\n    if(xs() % (size(a) + size(b)) < (u32) size(a)) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  friend int size(RBSTSeq *a) { return a == nullptr ? 0 : a->sz; }\n  using PNN = pair< RBSTSeq *, RBSTSeq * >;\n  // [0, k), [k, n)\n  // 左のグループにk個いれる\n  friend PNN split(RBSTSeq *a, int k) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    eval(a);\n    RBSTSeq *sl, *sr;\n    if(k <= size(a->l)) {\n      tie(sl, sr) = split(a->l, k);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend void insert(RBSTSeq *&a, int k, const X &x) {\n    RBSTSeq *sl, *sr;\n    tie(sl, sr) = split(a, k);\n    a = merge(sl, merge(new RBSTSeq(x), sr));\n  }\n  friend X erase(RBSTSeq *&a, int k) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    a = merge(tl, sr);\n    return tr->val;\n  }\n  friend void erase(RBSTSeq *&a, int l, int r) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    a = merge(tl, sr);\n  }\n  friend void set1(RBSTSeq *&a, int k, X const &x) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    if(tr != nullptr) tr->val = tr->accum = x;\n    a = merge(merge(tl, tr), sr);\n  }\n  friend X get(RBSTSeq *&a, int k) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    X res = tr == nullptr ? Monoid::identity() : tr->val;\n    a = merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void act(RBSTSeq *&a, int l, int r, M const &m) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->lazy = M_act::op(m, tr->lazy);\n    a = merge(merge(tl, tr), sr);\n  }\n  friend X query(RBSTSeq *&a, int l, int r) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    X res = tr == nullptr ? Monoid::identity() : tr->accum;\n    a = merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void reverse(RBSTSeq *&a, int l, int r) {\n    RBSTSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->rev ^= 1;\n    a = merge(merge(tl, tr), sr);\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid, M_act examples {{{ ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\n// MinAdd m + x\n// MinSet m\n// SumAdd m * n + x\n// SumSet m * n\n\nstruct RangeMinAdd {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll, const X &x) { return m + x; }\n};\n\nstruct RangeMinSet {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll, const X &) { return m; }\n};\n\nstruct RangeSumAdd {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll n, const X &x) { return m * n + x; }\n};\n\nstruct RangeSumSet {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll n, const X &) { return m * n; }\n};\n\n/// }}}--- ///\n\nRBSTSeq< RangeMin, RangeMinAdd > *seq = nullptr;","RBST Multiset Library":"/// --- RBST Multiset Library {{{ ///\n\ntemplate < class Key >\nstruct RBSTMultiset {\npublic:\n  const Key key;\n\nprivate:\n  using u32 = uint32_t;\n  using PNN = pair< RBSTMultiset*, RBSTMultiset* >;\n  RBSTMultiset *l = nullptr, *r = nullptr;\n  int sz = 1;\n  friend RBSTMultiset* prop(RBSTMultiset* a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    return a;\n  }\n  /// --- XorShift128 {{{ ///\n  struct XorShift128 {\n    using u32 = uint32_t;\n    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128(u32 seed = 0) { z ^= seed; }\n    u32 operator()() {\n      u32 t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n  /// }}}--- ///\npublic:\n  RBSTMultiset(Key key) : key(key) {}\n  friend RBSTMultiset* merge(RBSTMultiset* a, RBSTMultiset* b) {\n    static XorShift128 xs(__LINE__ * 3 + 5);\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    if(xs() % (size(a) + size(b)) < (u32) size(a)) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  // lower (-inf, key), [key, inf)\n  // upper (-inf, key], (key, inf)\n  friend PNN split(RBSTMultiset* a, Key key, bool upper) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    RBSTMultiset *sl, *sr;\n    if(upper ? key < a->key : !(a->key < key)) {\n      tie(sl, sr) = split(a->l, key, upper);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, key, upper);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend PNN lower_split(RBSTMultiset* a, const Key& key) {\n    return split(a, key, false);\n  }\n  friend PNN upper_split(RBSTMultiset* a, const Key& key) {\n    return split(a, key, true);\n  }\n  friend int size(RBSTMultiset* a) { return a == nullptr ? 0 : a->sz; }\n  friend void insert(RBSTMultiset*& a, Key key) {\n    RBSTMultiset *sl, *sr;\n    tie(sl, sr) = lower_split(a, key);\n    a = merge(sl, merge(new RBSTMultiset(key), sr));\n  }\n  friend void erase(RBSTMultiset*& a, Key key) {\n    RBSTMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = upper_split(a, key);\n    tie(tl, tr) = lower_split(sl, key);\n    a = merge(tl, sr);\n  }\n  friend void erase(RBSTMultiset*& a, Key keyL, Key keyR,\n                    bool inclusive = false) {\n    RBSTMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, keyR, inclusive);\n    tie(tl, tr) = lower_split(sl, keyL);\n    a = merge(tl, sr);\n  }\n  friend void erase1(RBSTMultiset*& a, Key key) {\n    if(a == nullptr) return;\n    if(key < a->key) {\n      erase1(a->l, key);\n    } else {\n      if(!(a->key < key)) {\n        a = merge(a->l, a->r);\n        return;\n      }\n      erase1(a->r, key);\n    }\n    prop(a);\n  }\n  friend Key getKth(RBSTMultiset*& a, int k) {\n    static const struct CannotGetKthOfNullptr {} ex;\n    if(a == nullptr) throw ex;\n    if(k <= size(a->l)) {\n      if(k == size(a->l)) return a->key;\n      return getKth(a->l, k);\n    } else {\n      return getKth(a->r, k - size(a->l) - 1);\n    }\n  }\n  friend int count(RBSTMultiset*& a, Key key) {\n    RBSTMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = upper_split(a, key);\n    tie(tl, tr) = lower_split(sl, key);\n    int cnt = size(tr);\n    a = merge(merge(tl, tr), sr);\n    return cnt;\n  }\n  friend int count(RBSTMultiset*& a, Key keyL, Key keyR,\n                   bool inclusive = false) {\n    RBSTMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, keyR, inclusive);\n    tie(tl, tr) = lower_split(sl, keyL);\n    int cnt = size(tr);\n    a = merge(merge(tl, tr), sr);\n    return cnt;\n  }\n};\n\n/// }}}--- ///\n\nRBSTMultiset< ll >* ms = nullptr;","Treap Sequence Library":"/// --- Treap Sequence Library {{{ ///\n\ntemplate < class Monoid, class M_act >\nstruct TreapSeq {\nprivate:\n  using u32 = uint32_t;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  TreapSeq *l = nullptr, *r = nullptr;\n  X val;\n  X accum = Monoid::identity();\n  M lazy = M_act::identity();\n  bool rev = false;\n  int sz = 1;\n  u32 pri;\n  // call after touch its child\n  // a is not nullptr and is evaled, its child is proped\n  friend TreapSeq *prop(TreapSeq *a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    a->accum =\n        Monoid::op(Monoid::op(Accumulated(a->l), a->val), Accumulated(a->r));\n    return a;\n  }\n  // call before use val, accum\n  friend void eval(TreapSeq *a) {\n    if(a->lazy != M_act::identity()) {\n      a->val = M_act::actInto(a->lazy, -1, 1, a->val);\n      a->accum = M_act::actInto(a->lazy, -1, a->sz, a->accum);\n      if(a->l != nullptr) a->l->lazy = M_act::op(a->lazy, a->l->lazy);\n      if(a->r != nullptr) a->r->lazy = M_act::op(a->lazy, a->r->lazy);\n      a->lazy = M_act::identity();\n    }\n    if(a->rev) {\n      swap(a->l, a->r);\n      if(a->l != nullptr) a->l->rev ^= 1;\n      if(a->r != nullptr) a->r->rev ^= 1;\n      a->rev = false;\n    }\n  }\n  friend X Accumulated(TreapSeq *a) {\n    return a == nullptr ? Monoid::identity() : (eval(a), a->accum);\n  }\n  /// --- XorShift128 {{{ ///\n  struct XorShift128 {\n    using u32 = uint32_t;\n    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128(u32 seed = 0) { z ^= seed; }\n    u32 operator()() {\n      u32 t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n  /// }}}--- ///\n  u32 nextPriority() {\n    static XorShift128 xs(__LINE__ * 3 + 5);\n    return xs();\n  }\n\npublic:\n  TreapSeq(X val, u32 pri) : val(val), pri(pri) {}\n  TreapSeq(X val = Monoid::identity()) : TreapSeq(val, nextPriority()) {}\n  friend TreapSeq *merge(TreapSeq *a, TreapSeq *b) {\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    eval(a);\n    eval(b);\n    if(a->pri > b->pri) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  friend int size(TreapSeq *a) { return a == nullptr ? 0 : a->sz; }\n  using PNN = pair< TreapSeq *, TreapSeq * >;\n  // [0, k), [k, n)\n  // 左のグループにk個いれる\n  friend PNN split(TreapSeq *a, int k) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    eval(a);\n    TreapSeq *sl, *sr;\n    if(k <= size(a->l)) {\n      tie(sl, sr) = split(a->l, k);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend void insert(TreapSeq *&a, int k, const X &x) {\n    TreapSeq *sl, *sr;\n    tie(sl, sr) = split(a, k);\n    a = merge(sl, merge(new TreapSeq(x), sr));\n  }\n  friend X erase(TreapSeq *&a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    a = merge(tl, sr);\n    return tr->val;\n  }\n  friend void erase(TreapSeq *&a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    a = merge(tl, sr);\n  }\n  friend void set1(TreapSeq *a, int k, X const &x) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    if(tr != nullptr) tr->val = tr->accum = x;\n    merge(merge(tl, tr), sr);\n  }\n  friend X get(TreapSeq *a, int k) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, k + 1);\n    tie(tl, tr) = split(sl, k);\n    X res = tr == nullptr ? Monoid::identity() : tr->val;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void act(TreapSeq *a, int l, int r, M const &m) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->lazy = M_act::op(m, tr->lazy);\n    merge(merge(tl, tr), sr);\n  }\n  friend X query(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    X res = tr == nullptr ? Monoid::identity() : tr->accum;\n    merge(merge(tl, tr), sr);\n    return res;\n  }\n  friend void reverse(TreapSeq *a, int l, int r) {\n    TreapSeq *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, r);\n    tie(tl, tr) = split(sl, l);\n    if(tr != nullptr) tr->rev ^= 1;\n    merge(merge(tl, tr), sr);\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid, M_act examples {{{ ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\n// MinAdd m + x\n// MinSet m\n// SumAdd m * n + x\n// SumSet m * n\n\nstruct RangeMinAdd {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll, const X &x) { return m + x; }\n};\n\nstruct RangeMinSet {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll, const X &) { return m; }\n};\n\nstruct RangeSumAdd {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll n, const X &x) { return m * n + x; }\n};\n\nstruct RangeSumSet {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll n, const X &) { return m * n; }\n};\n\n/// }}}--- ///\n\nTreapSeq< RangeMin, RangeMinSet > *seq = nullptr;","Treap Multiset Library":"/// --- Treap Multiset Library {{{ ///\n\ntemplate < class Key >\nstruct TreapMultiset {\npublic:\n  const Key key;\n\nprivate:\n  using u32 = uint32_t;\n  using PNN = pair< TreapMultiset*, TreapMultiset* >;\n  u32 pri;\n  TreapMultiset *l = nullptr, *r = nullptr;\n  int sz = 1;\n  // call after touch its child\n  friend TreapMultiset* prop(TreapMultiset* a) {\n    a->sz = size(a->l) + 1 + size(a->r);\n    return a;\n  }\n  /// --- XorShift128 {{{ ///\n  struct XorShift128 {\n    using u32 = uint32_t;\n    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    XorShift128(u32 seed = 0) { z ^= seed; }\n    u32 operator()() {\n      u32 t = x ^ (x << 11);\n      x = y, y = z, z = w;\n      return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n  };\n  /// }}}--- ///\n  u32 nextPriority() {\n    static XorShift128 xs(__LINE__ * 3 + 5);\n    return xs();\n  }\n\npublic:\n  TreapMultiset(Key key, u32 pri) : key(key), pri(pri) {}\n  TreapMultiset(Key key) : TreapMultiset(key, nextPriority()) {}\n  friend TreapMultiset* merge(TreapMultiset* a, TreapMultiset* b) {\n    if(a == nullptr) return b;\n    if(b == nullptr) return a;\n    if(a->pri > b->pri) {\n      a->r = merge(a->r, b);\n      return prop(a);\n    } else {\n      b->l = merge(a, b->l);\n      return prop(b);\n    }\n  }\n  // lower (-inf, key), [key, inf)\n  // upper (-inf, key], (key, inf)\n  friend PNN split(TreapMultiset* a, Key key, bool upper) {\n    if(a == nullptr) return PNN(nullptr, nullptr);\n    TreapMultiset *sl, *sr;\n    if(upper ? key < a->key : !(a->key < key)) {\n      tie(sl, sr) = split(a->l, key, upper);\n      a->l = sr;\n      return PNN(sl, prop(a));\n    } else {\n      tie(sl, sr) = split(a->r, key, upper);\n      a->r = sl;\n      return PNN(prop(a), sr);\n    }\n  }\n  friend PNN lower_split(TreapMultiset* a, const Key& key) {\n    return split(a, key, false);\n  }\n  friend PNN upper_split(TreapMultiset* a, const Key& key) {\n    return split(a, key, true);\n  }\n  friend int size(TreapMultiset* a) { return a == nullptr ? 0 : a->sz; }\n  friend void insert(TreapMultiset*& a, Key key) {\n    TreapMultiset *sl, *sr;\n    tie(sl, sr) = lower_split(a, key);\n    a = merge(sl, merge(new TreapMultiset(key), sr));\n  }\n  friend void erase(TreapMultiset*& a, Key key) {\n    TreapMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = upper_split(a, key);\n    tie(tl, tr) = lower_split(sl, key);\n    a = merge(tl, sr);\n  }\n  friend void erase(TreapMultiset*& a, Key keyL, Key keyR,\n                    bool inclusive = false) {\n    TreapMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, keyR, inclusive);\n    tie(tl, tr) = lower_split(sl, keyL);\n    a = merge(tl, sr);\n  }\n  friend void erase1(TreapMultiset*& a, Key key) {\n    if(a == nullptr) return;\n    if(key < a->key) {\n      erase1(a->l, key);\n    } else {\n      if(!(a->key < key)) {\n        a = merge(a->l, a->r);\n        return;\n      }\n      erase1(a->r, key);\n    }\n    prop(a);\n  }\n  friend Key getKth(TreapMultiset*& a, int k) {\n    static const struct CannotGetKthOfNullptr {} ex;\n    if(a == nullptr) throw ex;\n    if(k <= size(a->l)) {\n      if(k == size(a->l)) return a->key;\n      return getKth(a->l, k);\n    } else {\n      return getKth(a->r, k - size(a->l) - 1);\n    }\n  }\n  friend int count(TreapMultiset* a, Key key) {\n    TreapMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = upper_split(a, key);\n    tie(tl, tr) = lower_split(sl, key);\n    int cnt = size(tr);\n    merge(merge(tl, tr), sr);\n    return cnt;\n  }\n  friend int count(TreapMultiset* a, Key keyL, Key keyR,\n                   bool inclusive = false) {\n    TreapMultiset *sl, *sr, *tl, *tr;\n    tie(sl, sr) = split(a, keyR, inclusive);\n    tie(tl, tr) = lower_split(sl, keyL);\n    int cnt = size(tr);\n    merge(merge(tl, tr), sr);\n    return cnt;\n  }\n};\n\n/// }}}--- ///\n\nTreapMultiset< ll >* ms = nullptr;","LeftistHeap Library":"/// --- LeftistHeap Library {{{ ///\ntemplate < class T >\nstruct LeftistHeap {\n  LeftistHeap *l = nullptr, *r = nullptr;\n  T val;\n  int rnk;\n  LeftistHeap(T val = T()) : val(val) {}\n};\n\ntemplate < class T, class Compare = less< T > >\nLeftistHeap< T > *meld(LeftistHeap< T > *a, LeftistHeap< T > *b,\n                       const Compare &comp = Compare()) {\n  if(a == nullptr) return b;\n  if(b == nullptr) return a;\n  if(!comp(a->val, b->val)) swap(a, b);\n  a->r = meld(a->r, b, comp);\n  if(a->l == nullptr || a->l->rnk < a->r->rnk) swap(a->l, a->r);\n  a->rnk = ((a->r == nullptr) ? 0 : a->r->rnk) + 1;\n  return a;\n}\n\ntemplate < class T, class Compare = less< T > >\ninline LeftistHeap< T > *push(LeftistHeap< T > *&a, T const &e,\n                              const Compare &comp = Compare()) {\n  LeftistHeap< T > *b = new LeftistHeap< T >(e);\n  a = a == nullptr ? b : meld(a, b, comp);\n  return b;\n}\n\ntemplate < class T, class Compare = less< T > >\ninline void pop(LeftistHeap< T > *&a, const Compare &comp = Compare()) {\n  a = meld(a->l, a->r, comp);\n}\ntemplate < class T, class Compare = less< T > >\nLeftistHeap< T > *second(LeftistHeap< T > *a, const Compare &comp = Compare()) {\n  return a->r == nullptr ? a->l : comp(a->l->val, a->r->val) ? a->l : a->r;\n}\n/// }}}--- ///","SkewHeap Library":"/// --- SkewHeap Library {{{ ///\ntemplate < class T >\nstruct SkewHeap {\n  SkewHeap *l = nullptr, *r = nullptr;\n  T val;\n  SkewHeap(T val = T()) : val(val) {}\n};\n\ntemplate < class T, class Compare = less< T > >\nSkewHeap< T > *meld(SkewHeap< T > *a, SkewHeap< T > *b,\n                    const Compare &comp = Compare()) {\n  if(a == nullptr) return b;\n  if(b == nullptr) return a;\n  if(!comp(a->val, b->val)) swap(a, b);\n  a->r = meld(a->r, b, comp);\n  swap(a->l, a->r);\n  return a;\n}\n\ntemplate < class T, class Compare = less< T > >\ninline SkewHeap< T > *push(SkewHeap< T > *&a, T const &e,\n                           const Compare &comp = Compare()) {\n  SkewHeap< T > *b = new SkewHeap< T >(e);\n  a = a == nullptr ? b : meld(a, b, comp);\n  return b;\n}\n\ntemplate < class T, class Compare = less< T > >\ninline void pop(SkewHeap< T > *&a, const Compare &comp = Compare()) {\n  a = meld(a->l, a->r, comp);\n}\ntemplate < class T, class Compare = less< T > >\nSkewHeap< T > *second(SkewHeap< T > *a, Compare comp = Compare()) {\n  return a->r == nullptr ? a->l : comp(a->l->val, a->r->val) ? a->l : a->r;\n}\n/// }}}--- ///","BIT Library":"// NOTE : there's get and sum method.\n/// --- BIT Library {{{ ///\n\ntemplate < class T = ll >\nstruct BIT {\n  int n, m;\n  T identity;\n  vector< T > data;\n  BIT() : n(0) {}\n  BIT(int n, T identity = T()) : n(n), identity(identity), data(n, identity) {\n    m = 1;\n    while(m < n) m <<= 1;\n  }\n  void add(int i, T x) {\n    i++;\n    while(i <= n) {\n      data[i - 1] = data[i - 1] + x;\n      i += i & -i;\n    }\n  }\n  T sum(int i) {\n    if(i < 0) return identity;\n    if(i >= n) i = n - 1;\n    i++;\n    T s = identity;\n    while(i > 0) {\n      s = s + data[i - 1];\n      i -= i & -i;\n    }\n    return s;\n  }\n  T get(int i) { return sum(i) - inverse(sum(i - 1)); }\n  T range(int a, int b) { return sum(b) - inverse(sum(a - 1)); }\n  int lower_bound(T w) {\n    int i = 0;\n    for(int k = m; k > 0; k >>= 1) {\n      if(i + k <= n && data[i + k - 1] < w) w -= data[(i += k) - 1];\n    }\n    return i;\n  }\n};\n\n/// }}}--- ///\n\n// BIT<> bit(N);","2D BIT Library":"// NOTE : query in range and x1 <= x2, y is same\n/// --- 2D BIT Library {{{ ///\n\ntemplate < class T = ll, class V = function< T(T, T) > >\nstruct BIT2D {\n  int h, w;\n  T identity;\n  vector< T > dat;\n  BIT2D(int h, int w, T identity = T())\n      : h(h), w(w), identity(identity), dat(h * w, identity) {}\n  void add(int y, int x, T const &val) {\n    for(++y; y <= h; y += y & -y) addX(y, x, val);\n  }\n  void addRange(int y1, int x1, int y2, int x2, T const &val) {\n    add(y1, x1, val);\n    if(y2 + 1 < h) add(y2 + 1, x1, -val);\n    if(x2 + 1 < w) add(y1, x2 + 1, -val);\n    if(y2 + 1 < h && x2 + 1 < w) add(y2 + 1, x2 + 1, val);\n  }\n  void set(int y, int x, T val) { add(y, x, val - get(y, x)); }\n  T sum(int y, int x) {\n    if(y < 0 || x < 0) return 0;\n    T r = identity;\n    for(++y; y > 0; y -= y & -y) r += sumX(y, x);\n    return r;\n  }\n  T get(int y, int x) { return range(y, x, y, x); }\n  T range(int y1, int x1, int y2, int x2) {\n    return sum(y2, x2) - sum(y1 - 1, x2) - sum(y2, x1 - 1) +\n           sum(y1 - 1, x1 - 1);\n  }\n\nprivate:\n  inline int id(int y, int x) { return (y - 1) * w + (x - 1); }\n  void addX(int y, int x, T const &val) {\n    for(++x; x <= w; x += x & -x) dat[id(y, x)] += val;\n  }\n  T sumX(int y, int x) {\n    T r = identity;\n    for(++x; x > 0; x -= x & -x) r += dat[id(y, x)];\n    return r;\n  }\n};\n\n/// }}}--- ///","LinkCutTree Library":"// when link(p, c) , c is root.\n// cut(c), c is not root\n// use make(int index, Monoid::T x)\n// lc[index] to access nodes\n/// --- LinkCutTree Library {{{ ///\n\ntemplate < class Monoid, class M_act >\nstruct LinkCutTree {\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\n  // Splay sequence {{{\n  struct Splay {\n    Splay *ch[2] = {nullptr, nullptr}, *p = nullptr;\n    X val, accum;\n    M lazy = M_act::identity(); ///////\n    // size of BST // not of real subtree\n    int sz = 1;\n    bool isRoot() { return !p || (p->ch[0] != this && p->ch[1] != this); }\n    bool rev = false;\n    // call before use\n    void eval() {\n      if(lazy != M_act::identity()) {\n        val = M_act::actInto(lazy, -1, 1, val);\n        accum = M_act::actInto(lazy, -1, sz, accum);\n        if(ch[0]) ch[0]->lazy = M_act::op(lazy, ch[0]->lazy);\n        if(ch[1]) ch[1]->lazy = M_act::op(lazy, ch[1]->lazy);\n        lazy = M_act::identity();\n      }\n      if(rev) {\n        swap(ch[0], ch[1]);\n        if(ch[0]) ch[0]->rev ^= 1;\n        if(ch[1]) ch[1]->rev ^= 1;\n        // accum = reverse(accum, sz)\n        rev = false;\n      }\n    }\n    void evalDown() {\n      vector< Splay * > b2t;\n      Splay *t = this;\n      for(; !t->isRoot(); t = t->p) b2t.emplace_back(t);\n      t->eval();\n      while(b2t.size()) b2t.back()->eval(), b2t.pop_back();\n      // vector< Splay * >().swap(b2t);\n    }\n    X accumulated(Splay *a) { return !a ? Monoid::identity() : a->accum; }\n    int size(Splay *a) { return !a ? 0 : a->sz; }\n    // call after touch\n    void prop() {\n      if(ch[0]) ch[0]->eval(); ////\n      if(ch[1]) ch[1]->eval(); ////\n      sz = size(ch[0]) + 1 + size(ch[1]);\n      accum =\n          Monoid::op(Monoid::op(accumulated(ch[0]), val), accumulated(ch[1]));\n    }\n    Splay(const X &val) : val(val), accum(val) {}\n    Splay *rotate(bool R) {\n      Splay *t = ch[!R];\n      if((ch[!R] = t->ch[R])) ch[!R]->p = this;\n      t->ch[R] = this; ////\n      if((t->p = p)) {\n        if(t->p->ch[0] == this) t->p->ch[0] = t;\n        if(t->p->ch[1] == this) t->p->ch[1] = t;\n      }\n      p = t;\n      prop(), t->prop();\n      return t;\n    }\n    // bottom-up\n    void splay() {\n      evalDown();\n      while(!isRoot()) {\n        Splay *q = p;\n        if(q->isRoot()) {\n          q->rotate(q->ch[0] == this);\n        } else {\n          Splay *r = q->p;\n          bool V = r->ch[0] == q;\n          if(q->ch[!V] == this)\n            r->rotate(V);\n          else\n            q->rotate(!V);\n          p->rotate(V); ///////\n        }\n      }\n    }\n  };\n  // }}}\n\n  vector< Splay * > data;\n  LinkCutTree(int n) : data(n) {}\n  Splay *operator[](int i) { return data[i]; }\n  Splay *make(int i, const X &x = Monoid::identity()) {\n    return data[i] = new Splay(x);\n  }\n  const X &get(Splay *x) {\n    x->evalDown();\n    return x->val;\n  }\n  void set(Splay *x, const X &val) {\n    x->splay();\n    x->val = val;\n    x->prop();\n  }\n  Splay *expose(Splay *x) {\n    Splay *prv = nullptr, *now = x;\n    for(; now; prv = now, now = now->p) {\n      now->splay();\n      now->ch[1] = prv;\n      now->prop();\n    }\n    x->splay(); /////\n    return prv;\n  }\n  void cut(Splay *c) {\n    expose(c);\n#ifdef DEBUG\n    static const struct CannotCutRoot {} ex;\n    if(!c->ch[0]) throw ex;\n#endif\n    Splay *s = c->ch[0];\n    c->ch[0] = nullptr;\n    c->prop();\n    s->p = nullptr;\n  }\n  void link(Splay *parent, Splay *child) {\n#ifdef DEBUG\n    static const struct CannotLinkSameNode {} ex;\n    if(same(parent, child)) throw ex;\n#endif\n    expose(parent), expose(child);\n    child->p = parent;\n    parent->ch[1] = child;\n    parent->prop();\n  }\n  void evert(Splay *x) {\n    expose(x);\n    x->rev = true;\n  }\n  bool same(Splay *a, Splay *b) {\n    if(a == b) return true;\n    expose(a), expose(b);\n    return a->p != nullptr;\n  }\n  Splay *lca(Splay *a, Splay *b) {\n#ifdef DEBUG\n    static const struct CannotLCAAnotherNode {} ex;\n    if(!same(a, b)) throw ex;\n#endif\n    expose(a), a = expose(b);\n    return !a ? b : a;\n  }\n  void act(Splay *a, const M &m) { expose(a), a->lazy = m; }\n  X query(Splay *a) {\n    expose(a);\n    return a->accum;\n  }\n  // root of subtree\n  Splay *getRoot(Splay *a) {\n    expose(a);\n    Splay *t = a;\n    while(t->ch[0]) t = t->ch[0];\n    t->splay();\n    return t;\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid, M_act examples {{{ ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\n// MinAdd m + x\n// MinSet m\n// SumAdd m * n + x\n// SumSet m * n\n\nstruct RangeMinAdd {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll, const X &x) { return m + x; }\n};\n\nstruct RangeMinSet {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll, const X &) { return m; }\n};\n\nstruct RangeSumAdd {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll n, const X &x) { return m * n + x; }\n};\n\nstruct RangeSumSet {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll n, const X &) { return m * n; }\n};\n\n/// }}}--- ///\n\n// LinkCutTree< RangeSum, RangeSumSet > lc(N);","Sparse Table Library":"// NOTE : query in range!\n/// --- Sparse Table Library {{{ ///\n\ntemplate < class SemiLattice >\nstruct SparseTable {\n  using T = typename SemiLattice::T;\n  size_t n;\n  vector< size_t > log2;\n  vector< vector< T > > t;\n  T identity;\n  SparseTable() : n(0) {}\n  SparseTable(size_t n, T identity = T())\n      : n(n), log2(n + 1), identity(identity) {\n    for(size_t i = 2; i <= n; i++) log2[i] = log2[i >> 1] + 1;\n    t.resize(log2[n] + 1, vector< T >(n, identity));\n  }\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  SparseTable(InputIter first, InputIter last, T identity = T())\n      : SparseTable(distance(first, last), identity) {\n    copy(first, last, begin(t[0]));\n    build();\n  }\n  void set(size_t i, T val) { t[0][i] = val; }\n  T get(size_t i) { return t[0][i]; }\n  void build() {\n    for(size_t j = 0; j < log2[n]; j++) {\n      size_t w = 1 << j;\n      for(size_t i = 0; i + (w << 1) <= n; i++) {\n        t[j + 1][i] = SemiLattice::op(t[j][i], t[j][i + w]);\n      }\n    }\n  }\n  T query(size_t l, size_t r) {\n    if(r - l < 1) return identity;\n    size_t j = log2[r - l];\n    return SemiLattice::op(t[j][l], t[j][r - (1 << j)]);\n  }\n};\n\n/// }}}--- ///\n\n// SemiLattice examples {{{\n\nstruct RMQSL {\n  using T = int;\n  static T op(T const &a, T const &b) { return a < b ? a : b; }\n};\n\n// }}}\n\nSparseTable< RMQSL > rmq(N, inf);","Union Find Library":"/// --- Union Find Library {{{ ///\n\nstruct UF {\n  int n;\n  vector< int > par, rank;\n  UF(int n) : n(n), par(n, -1), rank(n, 0) {}\n  int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n  int size(int x) { return -par[find(x)]; }\n  bool same(int a, int b) { return find(a) == find(b); }\n  void unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b) return;\n    if(rank[a] > rank[b]) swap(a, b);\n    par[b] += par[a];\n    par[a] = b;\n    if(rank[a] == rank[b]) rank[b]++;\n  }\n};\n\n/// }}}--- ///","DynamicSegTree":"// Note : to get faster, use map by yourself\n// .entity : number of materialized leaves\n/// --- DynamicSegTree {{{ ///\n\ntemplate < class Monoid >\nstruct DynamicSegTree {\n  using T = typename Monoid::T;\n  struct Node {\n    T value;\n    Node *l = nullptr, *r = nullptr;\n    Node(T value = Monoid::identity()) : value(value) {}\n  };\n  Node *top = new Node;\n  int n;\n  DynamicSegTree() {}\n  DynamicSegTree(int t) {\n    n = 1;\n    while(t > n) n <<= 1;\n  }\n  void set(int i, T const &val) { set(i, val, 0, n, top); }\n\nprivate:\n  void set(int i, T const &val, int l, int r, Node *&node) {\n    if(i + 1 <= l || r <= i) return;\n    if(node == nullptr) node = new Node();\n    if(i <= l && r <= i + 1) {\n      node->value = val;\n      return;\n    }\n    set(i, val, l, (l + r) / 2, node->l);\n    set(i, val, (l + r) / 2, r, node->r);\n    node->value = Monoid::op(calc(node->l), calc(node->r));\n  }\n  inline T calc(Node *node) {\n    return node == nullptr ? Monoid::identity() : node->value;\n  }\n\npublic:\n  T query(int a, int b) {\n    if(a < 0 || b > n || b <= a) return Monoid::identity();\n    return query(a, b, 0, n, top);\n  }\n  T get(int i) { return query(i, i + 1); }\n\nprivate:\n  T query(int a, int b, int l, int r, Node *node) {\n    if(node == nullptr) return Monoid::identity();\n    if(b <= l || r <= a) return Monoid::identity();\n    if(a <= l && r <= b) return node->value;\n    return Monoid::op(query(a, b, l, (l + r) / 2, node->l),\n                      query(a, b, (l + r) / 2, r, node->r));\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\nusing RMQ = DynamicSegTree< RMQMonoid >;\nusing RSQ = DynamicSegTree< RSQMonoid >;\nusing RMaxQ = DynamicSegTree< RMaxQMonoid >;","Fractional Cascading SegmentTree Library":"// (y, x)\n// query(yl, yr, xl, xr)\n// only offline\n// only one update\n/// --- Fractional Cascading SegmentTree Library {{{ ///\n\ntemplate < class T, class U, class Index = ll >\nstruct FractionalCascadingSegTree {\n  int h;\n  vector< T > dat;\n  vector< vector< Index > > indices;\n  vector< vector< int > > L, R;\n  U identity;\n  function< void(T &, int x, const U &) > setX;\n  function< void(T &, vector< Index > &) > initX;\n  function< U(T &, int x1, int x2) > queryX;\n  function< U(const U &, const U &) > mergeX;\n  FractionalCascadingSegTree() {}\n  FractionalCascadingSegTree(\n      int tempH, //\n      function< void(T &, int, const U &) > const &setX,\n      function< void(T &, vector< Index > &) > const &initX,\n      function< U(T &, int, int) > const &queryX,\n      function< U(const U &, const U &) > const &mergeX, U identity = U(),\n      T initial = T())\n      : identity(identity),\n        setX(setX),\n        initX(initX),\n        queryX(queryX),\n        mergeX(mergeX) {\n    h = 1;\n    while(h < tempH) h <<= 1;\n    dat = vector< T >(2 * h, initial);\n    indices = vector< vector< Index > >(2 * h);\n    L = R = vector< vector< int > >(2 * h);\n  }\n  void index(int i, Index j) { indices[i + h - 1].emplace_back(j); }\n  void init(bool doUnique) {\n    for(int i = h * 2 - 2; i >= 0; i--) {\n      if(i >= h - 1) {\n        sort(begin(indices[i]), end(indices[i]));\n        if(doUnique)\n          indices[i].erase(\n              unique(begin(indices[i]), end(indices[i])), end(indices[i]));\n        initX(dat[i], indices[i]);\n        continue;\n      }\n      size_t lsz = indices[i * 2 + 1].size();\n      size_t rsz = indices[i * 2 + 2].size();\n      size_t nsz = lsz + rsz;\n      indices[i].resize(nsz);\n      L[i].resize(nsz + 1, lsz);\n      R[i].resize(nsz + 1, rsz);\n      size_t p1 = 0, p2 = 0;\n      while(p1 < lsz || p2 < rsz) {\n        L[i][p1 + p2] = p1;\n        R[i][p1 + p2] = p2;\n        if(p1 < lsz &&\n           (p2 == rsz || indices[i * 2 + 1][p1] <= indices[i * 2 + 2][p2])) {\n          indices[i][p1 + p2] = indices[i * 2 + 1][p1];\n          p1++;\n        } else {\n          indices[i][p1 + p2] = indices[i * 2 + 2][p2];\n          p2++;\n        }\n      }\n      initX(dat[i], indices[i]);\n    }\n  }\n  void set(int i, int j, U const &val) {\n    int lower =\n        lower_bound(begin(indices[0]), end(indices[0]), j) - begin(indices[0]);\n    set(i, lower, val, 0, h, 0);\n  }\n  void set(int i, int lower, U const &val, int l, int r, int k) {\n    if(i + 1 <= l || r <= i) return;\n    upd(dat[k], i, lower, val);\n    if(i <= l && r <= i + 1) return;\n    set(i, L[k][lower], val, l, (l + r) >> 1, k * 2 + 1);\n    set(i, R[k][lower], val, (l + r) >> 1, r, k * 2 + 2);\n  }\n  U query(int a, int b, int l, int r) {\n    int lower =\n        lower_bound(begin(indices[0]), end(indices[0]), l) - begin(indices[0]);\n    int upper =\n        lower_bound(begin(indices[0]), end(indices[0]), r) - begin(indices[0]);\n    return query(a, b, lower, upper, 0, h, 0);\n  }\n  U query(int a, int b, int lower, int upper, int l, int r, int k) {\n    if(b <= l || r <= a) return identity;\n    if(a <= l && r <= b) return queryX(dat[k], lower, upper);\n    return mergeX(\n        query(a, b, L[k][lower], L[k][upper], l, (l + r) >> 1, k * 2 + 1),\n        query(a, b, R[k][lower], R[k][upper], (l + r) >> 1, r, k * 2 + 2));\n  }\n};\n\n/// }}}--- ///\n\n// fc-seg expamle {{{\n\n// using Under = BIT<>;\n// using Data = ll;\n\nusing Under = SparseTable< RMQSL >;\nusing Value = RMQSL;\nusing Data = Value::T;\n\nFractionalCascadingSegTree< Under, Data > ecas(\n    N + 1,\n    // set y\n    [](Under &dat, int y, Data const &v) -> void {\n      dat.set(y, Value::op(dat.get(y), v));\n    },\n    // init y\n    [](Under &dat, vector< ll > indices) -> void {\n      dat = Under(indices.size()); // serve initial?\n    },\n    // [l, r) // WARN : l <= r\n    [](Under &dat, int l, int r) -> Data { return dat.query(l, r); },\n    // merge y-direction\n    [](Data a, Data b) -> Data { return a + b; });\n\n// }}}","LazySegmentTree Library":"// NOTE : query in range!\n/// --- LazySegmentTree Library {{{ ///\n\ntemplate < class Monoid, class M_act >\nstruct LazySegTree {\nprivate:\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n  int n, h;\n  std::vector< X > data;\n  std::vector< M > lazy;\n  std::vector< int > nodeLeft;\n  std::vector< int > nodeLength;\n  // call before use data[i]\n  void eval(int i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLeft[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(int i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(int i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1),\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegTree() : n(0) {}\n  LazySegTree(int n, X initial = Monoid::identity()) : n(n) {\n    h = 1;\n    while(1 << h < n) h++;\n    data.resize(2 * n, initial);\n    lazy.resize(2 * n, M_act::identity());\n    nodeLeft.resize(2 * n);\n    nodeLength.resize(2 * n, 1);\n    for(int i = 0; i < n; i++) nodeLeft[i + n] = i;\n    for(int i = n - 1; i > 0; i--) // fill from deep\n      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n      nodeLeft[i] = min(nodeLeft[i * 2], nodeLeft[i * 2 + 1]),\n      nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n  }\n  template < class InputIter,\n             class = typename std::iterator_traits< InputIter >::value_type >\n  LazySegTree(InputIter first, InputIter last)\n      : LazySegTree(std::distance(first, last)) {\n    copy(first, last, std::begin(data) + n);\n    for(int i = n - 1; i > 0; i--) // fill from deep\n      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n  void act(int l, int r, const M &m) {\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(int i, const X &x) {\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(int i) {\n    evalDown(i);\n    return data[i + n];\n  }\n  X query(int l, int r) {\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < std::min(r, n); i++)\n      DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << std::endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid, M_act examples {{{ ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\n// MinAdd m + x\n// MinSet m\n// SumAdd m * n + x\n// SumSet m * n\n\nstruct RangeMinAdd {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll, const X &x) { return m + x; }\n};\n\nstruct RangeMinSet {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll, const X &) { return m; }\n};\n\nstruct RangeSumAdd {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll n, const X &x) { return m * n + x; }\n};\n\nstruct RangeSumSet {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll n, const X &) { return m * n; }\n};\n\n/// }}}--- ///\n\nLazySegTree< RangeSum, RangeSumAdd > seg(N);","PersistentSegmentTree Library":"// NOTE : query in range!\n/// --- PersistentSegmentTree Library {{{ ///\n\ntemplate < class Monoid >\nstruct PersistentSegTree {\nprivate:\n  using T = typename Monoid::T;\n  int n;\n  vector< T > data;\n  vector< int > lch, rch;\n  int lastRoot = 0;\n\npublic:\n  PersistentSegTree() : n(0) {}\n  PersistentSegTree(int t) : data(1, Monoid::identity()), lch(1, 0), rch(1, 0) {\n    n = 1;\n    while(n < t) n <<= 1;\n  }\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  PersistentSegTree(InputIter first, InputIter last)\n      : PersistentSegTree(distance(first, last)) {\n    assign(first, last);\n  }\n  int set(int i, const T &v, int root = 0) {\n    if(root == 0) root = lastRoot;\n    int k = make();\n    set(i, v, 0, n, k, root);\n    lastRoot = k;\n    return k;\n  }\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  void assign(InputIter first, InputIter last) {\n    assert(n >= distance(first, last));\n    data.resize(n * 2 - 1, Monoid::identity());\n    lch.resize(n * 2 - 1, 0);\n    rch.resize(n * 2 - 1, 0);\n    copy(first, last, begin(data) + n - 1);\n    for(int i = n - 2; i >= 0; i--) {\n      data[i] = Monoid::op(data[lch[i] = i * 2 + 1], data[rch[i] = i * 2 + 2]);\n    }\n  }\n  void reserve(int qsize) {\n    int h = log(n);\n    data.reserve(n * 2 - 1 + qsize * h);\n    lch.reserve(n * 2 - 1 + qsize * h);\n    rch.reserve(n * 2 - 1 + qsize * h);\n  }\n  void set(int i, const T &v, int l, int r, int k, int prevK) {\n    if(r - l == 1) {\n      data[k] = v;\n      return;\n    }\n    lch[k] = lch[prevK];\n    rch[k] = rch[prevK];\n    int x = make(); //// important where to calc\n    if(i < ((l + r) >> 1)) {\n      lch[k] = x;\n      set(i, v, l, (l + r) >> 1, lch[k], lch[prevK]);\n    } else {\n      rch[k] = x;\n      set(i, v, (l + r) >> 1, r, rch[k], rch[prevK]);\n    }\n    data[k] = Monoid::op(data[lch[k]], data[rch[k]]);\n  }\n  T get(int i, int root = 0) { return query(i, i + 1, root); }\n  T query(int a, int b, int root = 0) {\n    if(root == 0) root = lastRoot;\n    return query(a, b, 0, n, root);\n  }\n  T query(int a, int b, int l, int r, int k) {\n    if(k == 0) return Monoid::identity();\n    if(b <= l || r <= a) return Monoid::identity();\n    if(a <= l && r <= b) return data[k];\n    return Monoid::op(query(a, b, l, (l + r) >> 1, lch[k]),\n                      query(a, b, (l + r) >> 1, r, rch[k]));\n  }\n\nprivate:\n  int make() {\n    data.emplace_back(Monoid::identity());\n    lch.emplace_back(0);\n    rch.emplace_back(0);\n    return data.size() - 1;\n  }\n  int log(int x) {\n    int t = 0;\n    while(x) x >>= 1, t++;\n    return t;\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\nusing RMQ = PersistentSegTree< RMQMonoid >;\nusing RSQ = PersistentSegTree< RSQMonoid >;\nusing RMaxQ = PersistentSegTree< RMaxQMonoid >;","SegmentTree Library":"// NOTE : query in range!\n/// --- SegmentTree Library {{{ ///\n\ntemplate < class Monoid >\nstruct SegTree {\nprivate:\n  using T = typename Monoid::T;\n  int n;\n  vector< T > data;\n  // call after touch data[i]\n  void prop(int i) { data[i] = Monoid::op(data[2 * i], data[2 * i + 1]); }\n\npublic:\n  SegTree() : n(0) {}\n  SegTree(int n, T initial = Monoid::identity()) : n(n) {\n    data.resize(n * 2, initial);\n    for(int i = n - 1; i > 0; i--)\n      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  SegTree(InputIter first, InputIter last) : SegTree(distance(first, last)) {\n    copy(first, last, begin(data) + n);\n    // fill from deep\n    for(int i = n - 1; i > 0; i--) prop(i);\n  }\n  void set(int i, const T &v) {\n    data[i += n] = v;\n    while(i >>= 1) prop(i); // propUp\n  }\n  T get(int i) { return data[i + n]; }\n  T query(int l, int r) {\n    T tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) tmpL = Monoid::op(tmpL, data[l++]);\n      if(r & 1) tmpR = Monoid::op(data[--r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\nusing RMQ = SegTree< RangeMin >;\nRMQ rmq(N);","2D SegmentTree Library":"// constructor(int sizex, int sizey, T identity, func merge)\n// WARN : query in range by yourself!\n/// --- 2D SegmentTree Library {{{ ///\n\ntemplate < class T >\nstruct SegTree2D {\n  vector< T > dat;\n  int sizex, sizey;\n  T identity;\n  function< T(T, T) > merge;\n  SegTree2D(int tx, int ty, T identity, function< T(T, T) > merge)\n      : identity(identity), merge(merge) {\n    sizex = sizey = 1;\n    while(tx > sizex) sizex <<= 1;\n    while(ty > sizey) sizey <<= 1;\n    dat = vector< T >(sizex * sizey * 4, identity);\n  }\n  void set(int x, int y, T const &val) {\n    int kx = x + sizex - 1, ky = y + sizey - 1;\n    dat[kx * sizey * 2 + ky] = val;\n    sety(kx, y);\n    while(kx > 0) {\n      kx = (kx - 1) / 2;\n      ky = y + sizey - 1;\n      dat[kx * sizey * 2 + ky] = merge(dat[(kx * 2 + 1) * sizey * 2 + ky],\n                                       dat[(kx * 2 + 2) * sizey * 2 + ky]);\n      sety(kx, y);\n    }\n  }\n  void act(int x, int y, T const &val) {\n    int kx = x + sizex - 1, ky = y + sizey - 1;\n    set(x, y, merge(dat[kx * sizey * 2 + ky], val));\n  }\n\nprivate:\n  void sety(int kx, int y) {\n    int ky = y + sizey - 1;\n    while(ky > 0) {\n      ky = (ky - 1) / 2;\n      dat[kx * sizey * 2 + ky] = merge(\n          dat[kx * sizey * 2 + ky * 2 + 1], dat[kx * sizey * 2 + ky * 2 + 2]);\n    }\n  }\n\npublic:\n  T query(int xl, int xr, int yl, int yr) {\n    return queryx(xl, xr, yl, yr, 0, sizex, 0);\n  }\n\nprivate:\n  T queryx(int xl, int xr, int yl, int yr, int sxl, int sxr, int k) {\n    if(xr <= sxl || sxr <= xl) return identity;\n    if(xl <= sxl && sxr <= xr) return queryy(k, yl, yr, 0, sizey, 0);\n    return merge(queryx(xl, xr, yl, yr, sxl, (sxl + sxr) / 2, k * 2 + 1),\n                 queryx(xl, xr, yl, yr, (sxl + sxr) / 2, sxr, k * 2 + 2));\n  }\n  T queryy(int kx, int yl, int yr, int syl, int syr, int k) {\n    if(yr <= syl || syr <= yl) return identity;\n    if(yl <= syl && syr <= yr) return dat[kx * sizey * 2 + k];\n    return merge(queryy(kx, yl, yr, syl, (syl + syr) / 2, k * 2 + 1),\n                 queryy(kx, yl, yr, (syl + syr) / 2, syr, k * 2 + 2));\n  }\n};\n\n/// }}}--- ///","Geometory Library":"using Scalar = long double;\n// EPS\nconstexpr Scalar EPS = 1e-11;\nconstexpr Scalar PI = 3.14159265358979323;\n/// --- Geometory Library {{{ ///\nusing Point = complex< Scalar >;\nusing Polygon = vector< Point >;\nstruct Line : public pair< Point, Point > {\n  Line(Point a, Point b) : pair< Point, Point >(a, b) {}\n};\nstruct Segment : public pair< Point, Point > {\n  Segment(Point a, Point b) : pair< Point, Point >(a, b) {}\n};\n#define X real()\n#define Y imag()\n#define dot(a, b) real(conj(a) * (b))\n#define cross(a, b) imag(conj(a) * (b))\n#define norm abs\n\nint sign(Scalar x) {\n  if(x < -EPS) return -1;\n  if(x > +EPS) return +1;\n  return 0;\n}\n\n// +1 : a->b->c is ccw\n// -1 : a->b->c is cw\n// +2 : a--b--c\n// -2 : b--c--a\n//  0 : b--a--c\nint ccw(const Point &a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return 0;\n  if(norm(b) < norm(c)) return +2;\n  return -2;\n}\n\ninline Point normalize(const Point &v) { return v / norm(v); }\n\ninline Point normal(const Point &v) {\n  return v * Point(cos(PI / 2), sin(PI / 2));\n}\n\n// [0, pi]\nScalar arg(const Point &a, const Point &b) {\n  return acos(dot(a, b) / norm(a) / norm(b));\n}\n\n// triangle, arg a\nScalar arg(Scalar a, Scalar b, Scalar c) {\n  return acos((b * b + c * c - a * a) / (2 * b * c));\n}\n\n// Sarrus\nScalar area3(const Point &a, const Point &b) {\n  return abs(a.X * b.Y - a.Y * b.X) / 2;\n}\n\n// Heron's formula\nScalar area3(Scalar a, Scalar b, Scalar c) {\n  Scalar s = (a + b + c) / 2;\n  return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\nScalar dist(const Line &line, const Point &p) {\n  return cross(p - line.first, line.second - line.first) /\n         abs(line.second - line.first);\n}\n\nScalar dist(const Segment &segment, const Point &p) {\n  if(sign(dot(segment.first - segment.second, p - segment.second)) *\n         sign(dot(segment.second - segment.first, p - segment.first)) >=\n     0)\n    return dist(Line(segment.first, segment.second), p);\n  else\n    return min(norm(p - segment.first), norm(p - segment.second));\n}\n\nScalar dist(const Segment &a, const Segment &b) {\n  return min({\n      dist(a, b.first),\n      dist(a, b.second),\n      dist(b, a.first),\n      dist(b, a.second),\n  });\n}\n\nbool isCrossing(const Segment &a, const Segment &b) {\n  return ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <=\n             0 &&\n         ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <=\n             0;\n}\n\nPoint intersection(const Line &a, const Line &b) {\n  return a.first +              //\n         (a.second - a.first) * //\n             cross(a.first - b.first, b.second - b.first) *\n             cross(a.first - a.second, b.second - b.first);\n}\n\n/// }}}--- ///","Geometory Circle Library":"/// --- Geometory Circle Library {{{ ///\n// center, radius\nusing Circle = pair< Point, Scalar >;\n\n// -1 : 0 share (outside)\n//  1 : 0 share (B in A)\n//  2 : 0 share (A in B)\n// -3 : 1 share (outside)\n//  3 : 1 share (B in A)\n//  4 : 1 share (A in B)\n//  0 : 2 share\nint cpr(const Circle &a, const Circle &b) {\n  Scalar d = norm(a.first - b.first);\n  if(a.second + b.second + EPS < d) return -1;\n  if(b.second + d + EPS < a.second) return 1;\n  if(a.second + d + EPS < b.second) return 2;\n  if(abs(a.second + b.second - d) < EPS) return -3;\n  if(abs(b.second + d - a.second) < EPS) return 3;\n  if(abs(a.second + d - b.second) < EPS) return 4;\n  return 0;\n}\n\nvector< Point > intersections(const Circle &a, const Circle &b) {\n  vector< Point > res;\n  // normalize(b-a) * R_A\n  Point x = a.second * normalize(b.first - a.first);\n  if(abs(cpr(a, b)) >= 3) {\n    res.emplace_back(a.first + x);\n  } else if(cpr(a, b) == 0) {\n    Scalar s = arg(b.second, norm(b.first - a.first), a.second);\n    res.emplace_back(a.first + x * Point(cos(s), sin(s)));\n    res.emplace_back(a.first + x * Point(cos(-s), sin(-s)));\n  }\n  return res;\n}\n\nvector< Point > intersections(const Circle &a, const Line &line) {\n  vector< Point > res;\n  Point n = normal(line.first - line.second);\n  Point p = intersection(line, Line(a.first, a.first + n));\n  Scalar d = norm(a.first - p);\n  if(abs(d - a.second) < EPS) {\n    res.emplace_back(p);\n  } else if(abs(d) < a.second) {\n    Scalar len = sqrt(a.second * a.second - d * d);\n    Point share = len * normalize(line.first - line.second);\n    res.emplace_back(p + share);\n    res.emplace_back(p - share);\n  }\n  return res;\n}\n\ninline Scalar area(const Circle &a) { return PI * a.second * a.second; }\n\nScalar shareArea(Circle a, Circle b) {\n  Scalar d = norm(a.first - b.first);\n  if(a.second + b.second < d + EPS) return 0;\n  if(a.second < b.second) swap(a, b);\n  if(b.second + d < a.second + EPS) return area(b);\n  Scalar s1 = arg(b.second, a.second, d), s2 = arg(a.second, b.second, d);\n  Scalar tri2 =\n      (a.second * a.second * sin(s1 * 2) + b.second * b.second * sin(s2 * 2)) /\n      2;\n  return a.second * a.second * s1 + b.second * b.second * s2 - tri2;\n}\n\ninline Line ajacentLine(const Circle &c, const Point &p) {\n  return Line(p, p + normal(p - c.first));\n}\n\n// the tangentLine of c passing p\nvector< Line > tangentLines(const Circle &c, const Point &p) {\n  vector< Line > res;\n  Scalar d = norm(p - c.first);\n  if(abs(d - c.second) < EPS)\n    res.emplace_back(ajacentLine(c, p));\n  else if(c.second < d) {\n    Point a = c.first + c.second * normalize(p - c.first);\n    vector< Point > b = intersections(\n        Circle(c.first, norm(c.first - p)), Line(a, a + normal(c.first - p)));\n    for(size_t i = 0; i < b.size(); i++) {\n      res.emplace_back(p, c.first + c.second * normalize(b[i] - c.first));\n    }\n  }\n  return res;\n}\n\nvector< Line > commonTangentLines(Circle a, Circle b) {\n  vector< Line > res;\n  if(a.second + EPS < b.second) swap(a, b);\n  if(norm(a.first - b.first) < EPS) return res;\n\n  Point p = a.first + (b.first - a.first) * a.second / (a.second + b.second);\n  if(norm(a.first - p) + EPS > a.second) res = tangentLines(a, p);\n  if(abs(a.second - b.second) < EPS) {\n    Point n = normal(normalize(b.first - a.first) * a.second);\n    res.emplace_back(a.first + n, b.first + n);\n    res.emplace_back(a.first - n, b.first - n);\n  } else {\n    Point q = a.first + (b.first - a.first) * a.second / (a.second - b.second);\n    if(abs(a.first - q) + EPS > a.second) {\n      vector< Line > tmp = tangentLines(a, q);\n      res.insert(begin(res), begin(tmp), end(tmp));\n    }\n  }\n  return res;\n}\n\n/// }}}--- ///","Geometory Polygon Library":"/// --- Geometory Polygon Library {{{ ///\n// ok for either ccw or cw\nScalar area(const Polygon &poly) {\n  if(poly.size() < 3) return 0;\n  Scalar res = cross(poly[poly.size() - 1], poly[0]);\n  for(size_t i = 0; i < poly.size() - 1; i++) {\n    res += cross(poly[i], poly[i + 1]);\n  }\n  return abs(res) / 2;\n}\n\n//  0 : outside\n//  1 : inside\n// -1 : on vertex\n// -2 : on line\nint inside(const Polygon &poly, const Point &p) {\n  int cnt = 0;\n  for(size_t i = 0; i < poly.size(); i++) {\n    size_t ii = i, jj = (i + 1) % poly.size();\n    if(norm(poly[i] - p) < EPS) return -1;\n    if(poly[ii].Y > poly[jj].Y) swap(ii, jj);\n    if(poly[ii].Y - EPS < p.Y && p.Y < poly[jj].Y + EPS) {\n      if(abs(poly[ii].Y - poly[jj].Y) < EPS) { // parallel\n        if(poly[ii].X > poly[jj].X) swap(ii, jj);\n        if(poly[ii].X - EPS < p.X && p.X < poly[jj].X + EPS) return -2;\n      } else {\n        Point q =\n            intersection(Line(poly[ii], poly[jj]), Line(p, p + Point(1, 0)));\n        if(p.X < q.X && p.Y > poly[ii].Y + EPS) cnt++; // count only upside\n      }\n    }\n  }\n  return cnt & 1;\n}\n\n// param ccwConvex must be ccw and convex\nScalar caliper(const Polygon &ccwConvex) {\n  constexpr auto comp = [](Point a, Point b) {\n    return a.X == b.X ? a.Y < b.Y : a.X < b.X;\n  };\n  size_t i, j;\n  for(size_t k = 0; k < ccwConvex.size(); k++) {\n    if(comp(ccwConvex[i], ccwConvex[k])) j = k;\n    if(!comp(ccwConvex[j], ccwConvex[k])) i = k;\n  }\n  Scalar res = 0;\n  size_t si = i, sj = j;\n  while(i != si || j != sj) {\n    res = max(res, norm(ccwConvex[i] - ccwConvex[j]));\n    if(cross(ccwConvex[(i + 1) % ccwConvex.size()] - ccwConvex[i],\n             ccwConvex[(j + 1) % ccwConvex.size()] - ccwConvex[j]) < 0)\n      i = (i + 1) % ccwConvex.size();\n    else\n      j = (j + 1) % ccwConvex.size();\n  }\n  return res;\n}\n/// }}}--- ///","Graham Scan - Polar Sort - Library":"// require Geometory Library!\n/// --- Graham Scan - Polar Sort - Library {{{ ///\n\n// make ConvexHull\n\n// if there are 3 points on line,\n// just guaranteed that point on hull is scanned exactly;\n// if on Line of Hull, sometimes scanned as on Hull.\nstruct GrahamScan {\n  Polygon poly;\n  vector< size_t > ids;\n  vector< size_t > hull;\n\n  void add(Point p) { poly.emplace_back(p); }\n\n  int operator[](int i) {\n    return hull[(i % hull.size() + hull.size()) % hull.size()];\n  }\n\n  void scan() {\n    ids.resize(poly.size());\n    iota(begin(ids), end(ids), 0);\n\n    size_t startID = 0;\n    for(size_t i = 1; i < poly.size(); i++) {\n      if(make_pair(poly[startID].X, poly[startID].Y) >\n         make_pair(poly[i].X, poly[i].Y))\n        startID = i;\n    }\n    swap(ids[0], ids[startID]);\n\n    sort(begin(ids) + 1, end(ids), [&](int a, int b) {\n      Point p1 = poly[a] - poly[ids[0]];\n      Point p2 = poly[b] - poly[ids[0]];\n      // p1.y / p1.x < p2.y / p2.x\n      double ev = p1.Y * p2.X - p2.Y * p1.X;\n      return abs(ev) < EPS ? norm(p1) < norm(p2) : ev < 0;\n    });\n\n    hull.emplace_back(ids[0]);\n    for(size_t i = 1; i <= poly.size(); i++) {\n      size_t ii = i % poly.size();\n      while(hull.size() >= 2 &&\n            ccw(poly[hull[hull.size() - 2]], poly[hull[hull.size() - 1]],\n                poly[ids[ii]]) == -1)\n        hull.pop_back();\n      hull.emplace_back(ids[ii]);\n    }\n\n    hull.pop_back();\n  }\n};\n\n/// }}}--- ///","Biconnected Component Decomposition":"// NOTE : 二重連結成分分解\n/// --- Biconnected Component Decomposition {{{ ///\n\nstruct Biconnected {\n  int n;\n  vector< vector< int > > g;\n  vector< int > low, ord, used;\n  vector< vector< pair< int, int > > > comps;\n  int id = 0;\n  vector< pair< int, int > > tmp;\n  Biconnected(vector< vector< int > > g)\n      : n(g.size()), g(g), low(n), ord(n), used(n) {\n    for(int i = 0; i < n; i++)\n      if(!used[i]) dfs(i);\n  }\n\nprivate:\n  void dfs(int i, int p = -1) {\n    used[i] = 1;\n    ord[i] = low[i] = id++;\n    for(int j : g[i])\n      if(j != p) {\n        pair< int, int > e(min(i, j), max(i, j));\n        if(used[j]) {\n          if(ord[i] > ord[j]) tmp.emplace_back(e);\n          low[i] = min(low[i], ord[j]);\n        } else {\n          tmp.emplace_back(e);\n          dfs(j, i);\n          low[i] = min(low[i], low[j]);\n          if(low[j] >= ord[i]) {\n            comps.push_back({});\n            while(1) {\n              pair< int, int > ne = tmp.back();\n              comps.back().emplace_back(ne);\n              tmp.pop_back();\n              if(e == ne) break;\n            }\n          }\n        }\n      }\n  }\n};\n\n/// }}}--- ///","Biedge Component Decomposition Libary":"// !! require Lowlink !!\n// NOTE : 二辺連結成分分解\n// Biedge(built-lowlink)\n// Biedge(graph)\n// NOTE : Biedge.tree, .comp\n/// --- Biedge Component Decomposition Libary {{{ ///\n\nstruct Biedge {\n  Lowlink lowlink;\n  vector< int > comp;\n  vector< vector< int > > tree;\n\n  Biedge(Lowlink lowlink) : lowlink(lowlink) { decomposite(); }\n  Biedge(vector< vector< int > > g) : lowlink(g) {\n    lowlink.build();\n    decomposite();\n  }\n\n  vector< int > used;\n\nprivate:\n  void decomposite() {\n    int n = lowlink.n;\n\n    tree.resize(n);\n    used.resize(n, 0);\n    comp.resize(n, -1);\n\n    int gid = 0;\n    for(int i = 0; i < n; i++)\n      if(!used[i]) dfs(gid++, i, -1);\n\n    tree.resize(gid);\n  }\n\n  void dfs(int gid, int i, int p) {\n    used[i] = 1;\n    comp[i] = gid;\n    for(auto edge : lowlink.g[i]) {\n      int j = edge.to;\n      int idx = edge.idx;\n      if(j == p) continue;\n      if(lowlink.isBridge[idx]) {\n        if(used[j]) {\n          tree[gid].emplace_back(comp[j]);\n          tree[comp[j]].emplace_back(gid);\n        }\n      } else if(!used[j]) {\n        dfs(gid, j, i);\n      }\n    }\n  }\n};\n\n/// }}}--- ///","Doubilng Tree Library":"// DoublingTree ( <graph> , initial? )\n// set (i, val) or assign ( <data> )\n// WARN : build(root = 0) !!!\n//     or dfs(roots) & init() !!\n// lca (a, b)\n// query(hi, a, hi_inclusive?)\n/// --- Doubilng Tree Library {{{ ///\n\ntemplate < class Monoid >\nstruct DoublingTree {\n  using T = typename Monoid::T;\n  int n, logn;\n  vector< vector< int > > tree;\n  vector< int > depth; // 0-indexed\n  // [logn][n]\n  vector< vector< int > > par;\n  vector< vector< T > > dat;\n  int log(int n) {\n    int h = 1;\n    while((1 << h) < n) h++;\n    return h;\n  }\n  DoublingTree(int n, const T &initial = Monoid::identity())\n      : n(n),\n        logn(log(n)),\n        tree(n),\n        depth(n),\n        par(logn, vector< int >(n)),\n        dat(logn, vector< T >(n, initial)) {}\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  DoublingTree(InputIter first, InputIter last,\n               const T &initial = Monoid::identity())\n      : DoublingTree(distance(first, last), initial) {\n    copy(first, last, begin(tree));\n  }\n  DoublingTree(const vector< vector< int > > &tree,\n               const T &initial = Monoid::identity())\n      : DoublingTree(begin(tree), end(tree), initial) {}\n  void set(int i, const T &val) { dat[0][i] = val; }\n  template < class InputIter,\n             class = typename iterator_traits< InputIter >::value_type >\n  void assign(InputIter first, InputIter last) {\n    assert(distance(first, last) <= n);\n    copy(first, last, begin(dat[0]));\n  }\n  void build(const vector< int > &roots) {\n    for(int root : roots) dfs(root);\n    init();\n  }\n  void build(int root = 0) {\n    dfs(root);\n    init();\n  }\n  void init() {\n    for(int k = 1; k < logn; k++) {\n      for(int i = 0; i < n; i++) {\n        int p = par[k - 1][i];\n        if(p == -1) {\n          par[k][i] = -1;\n          continue;\n        }\n        dat[k][i] = Monoid::op(dat[k - 1][p], dat[k - 1][i]);\n        par[k][i] = par[k - 1][p];\n      }\n    }\n  }\n  void dfs(int i, int p = -1, int d = 0) {\n    depth[i] = d;\n    par[0][i] = p;\n    for(int j : tree[i])\n      if(j != p) {\n        dfs(j, i, d + 1);\n      }\n  }\n\npublic:\n  int lca(int a, int b) {\n    if(depth[a] < depth[b]) swap(a, b);\n    for(int k = logn - 1; k >= 0; k--) {\n      int na = par[k][a];\n      if(na == -1 || depth[na] < depth[b]) continue;\n      a = na;\n    }\n    if(a == b) return a;\n    for(int k = logn - 1; k >= 0; k--) {\n      int na = par[k][a];\n      int nb = par[k][b];\n      if(na == nb) continue;\n      a = na, b = nb;\n    }\n    return par[0][a];\n  }\n  T query(int hi, int a, bool inclusive = true) {\n    T res = Monoid::identity();\n    for(int k = logn - 1; k >= 0; k--) {\n      int na = par[k][a];\n      if(na == -1 || depth[na] < depth[hi]) continue;\n      res = Monoid::op(dat[k][a], res);\n      a = na;\n    }\n    if(inclusive) res = Monoid::op(dat[0][hi], res);\n    return res;\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\nDoublingTree< RangeSum > eca(N);","BipartiteMatching Library":"/// --- BipartiteMatching Library {{{ ///\nstruct BipartiteMatching {\n  int n;\n  vector< vector< int > > graph;\n\n  BipartiteMatching(int n) : n(n), graph(n) {}\n  void addEdge(int a, int b) {\n    graph[a].emplace_back(b);\n    graph[b].emplace_back(a);\n  }\n\n  vector< int > used;\n  vector< int > match;\n\n  // max flow\n  int solve() {\n    match = vector< int >(n, -1);\n    int flow = 0;\n    for(int i = 0; i < n; i++) {\n      if(match[i] < 0) {            ///\n        used = vector< int >(n, 0); ///\n        if(dfs(i)) flow++;\n      }\n    }\n    return flow;\n  }\n\nprivate:\n  bool dfs(int v) {\n    if(used[v]) return false; ///\n    used[v] = 1;\n    for(int u : graph[v])\n      if(match[u] < 0 || dfs(match[u])) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    return false;\n  }\n};\n/// }}}--- ///","Dinic Libary":"/// --- Dinic Libary {{{ ///\n// solve max flow\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n\n  void addEdge(int a, int b, ll cap, int i = -1, bool undirected = false) {\n    if(i == -1) i = edges.size();\n    edges.resize(max(i + 1, (int) edges.size()));\n    edges[i] = (Edge){a, b, cap, undirected ? cap : 0};\n    g[a].emplace_back(i);\n    g[b].emplace_back(i);\n  }\n\n  ll solve(int s, int t) {\n    vector< int > level(n);\n    ll flow = 0;\n    while(bfs(s, level), level[t] > 0) {\n      ll newflow = dfs(s, t, inf, level);\n      if(newflow == 0) break;\n      flow += newflow;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] == -1 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///","Max Flow with FordFulkerson Library":"/// --- Max Flow with FordFulkerson Library {{{ ///\n\n// Ford-Fulkerson\n// O(FV)\nstruct Ford {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Ford(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n\n  void addEdge(int a, int b, ll cap, int i = -1, bool undirected = false) {\n    if(i == -1) i = edges.size();\n    edges.resize(max(i + 1, (int) edges.size()));\n    edges[i] = (Edge){a, b, cap, undirected ? cap : 0};\n    g[a].emplace_back(i);\n    g[b].emplace_back(i);\n  }\n\n  ll solve(int s, int t) {\n    ll flow = 0;\n    while(1) {\n      vector< int > used(n, 0);\n      ll x = dfs(used, s, t, inf);\n      if(x == 0) break;\n      flow += x;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n\nprivate:\n  ll dfs(vector< int >& used, int i, int t, ll x) {\n    if(i == t) return x;\n    used[i] = 1;\n    for(int idx : g[i])\n      if(!used[edges[idx].To(i)] && edges[idx].Cap(i) > 0) {\n        Edge& edge = edges[idx];\n        ll d = dfs(used, edge.To(i), t, min(x, edge.Cap(i)));\n        if(d == 0) continue; ////\n        edge.Cap(i) -= d;\n        edge.Rev(i) += d;\n        return d;\n      }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\n// const int N = 2e6;\n// Ford flow(N, 1e18);","MinCostFlow Library":"/// --- MinCostFlow Library {{{ ///\nstruct MinCostFlow {\n  struct Edge {\n    int to;\n    ll cap, cost;\n    size_t rev;\n  };\n  int n;\n  vector< vector< Edge > > graph;\n  vector< ll > dist;\n  vector< int > prevv, previ;\n  ll inf;\n  MinCostFlow(int n, ll inf)\n      : n(n), graph(n), dist(n), prevv(n), previ(n), inf(inf) {}\n  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {\n    graph[a].emplace_back((Edge){b, cap, cost, graph[b].size()});\n    graph[b].emplace_back(\n        (Edge){a, undirected ? cap : 0, -cost, graph[a].size() - 1});\n  }\n  ll solve(int s, int t, ll f) {\n    ll res = 0;\n    while(f > 0) {\n      fill(begin(dist), end(dist), inf);\n      dist[s] = 0;\n      bool update = 1;\n      // Bellman-Ford\n      while(update) {\n        update = 0;\n        for(int v = 0; v < n; v++) {\n          if(dist[v] == inf) continue;\n          for(size_t i = 0; i < graph[v].size(); i++) {\n            Edge &edge = graph[v][i];\n            if(edge.cap > 0 && dist[edge.to] > dist[v] + edge.cost) {\n              dist[edge.to] = dist[v] + edge.cost;\n              prevv[edge.to] = v;\n              previ[edge.to] = i;\n              update = 1;\n            }\n          }\n        }\n      }\n      //\n      if(dist[t] == inf) return -1;\n      ll d = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][previ[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        Edge &edge = graph[prevv[v]][previ[v]];\n        edge.cap -= d;\n        graph[v][edge.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n/// }}}--- ///\n\n// const int N = 100000;\n// ll inf = 1e18;\n// MinCostFlow ecas(N, inf);","HL-Decomposition Library":"// query(hi, lo, func, inclusive?)\n// hld[i] : index on sequence\n// WARN : build after adding edges!\n/// --- HL-Decomposition Library {{{ ///\n\nstruct HLD {\n  int n;\n  vector< int > head;\n  vector< int > sz;\n  vector< int > dep;\n  vector< int > par;\n  vector< int > vid;\n  int id = 0;\n  vector< vector< int > > g; // tree\n  HLD(int n) : n(n), head(n), sz(n), dep(n), par(n), vid(n), g(n) {}\n  HLD(vector< vector< int > > g, int root = 0) : HLD(g.size()) {\n    this->g = g;\n    build(root);\n  }\n  int operator[](int i) { return vid[i]; }\n  void addEdge(int a, int b) {\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  void build(int root = 0) {\n    head[root] = root;\n    dfs0(root, -1, 0);\n    dfs1(root, -1);\n  }\n  int lca(int a, int b) {\n    while(1) {\n      if(vid[a] > vid[b]) swap(a, b);\n      if(head[a] == head[b]) return a;\n      b = par[head[b]];\n    }\n  }\n  void query(int hi, int lo, function< void(int, int) > f,\n             bool inclusive = true) {\n    while(lo != -1 && dep[lo] >= dep[hi]) {\n      int nex = max(vid[head[lo]], vid[hi]);\n      f(nex + (nex == vid[hi] && !inclusive), vid[lo] + 1);\n      lo = par[head[lo]];\n    }\n  }\n\nprivate:\n  void dfs0(int i, int p, int d) {\n    par[i] = p;\n    sz[i] = 1;\n    dep[i] = d;\n    for(int &j : g[i])\n      if(j != p) {\n        dfs0(j, i, d + 1);\n        sz[i] += sz[j];\n        if(sz[j] > sz[g[i][0]]) {\n          swap(g[i][0], j);\n        }\n      }\n  }\n  void dfs1(int i, int p) {\n    vid[i] = id++;\n    for(int j : g[i])\n      if(j != p) {\n        head[j] = j == g[i][0] ? head[i] : j;\n        dfs1(j, i);\n      }\n  }\n};\n\n/// }}}--- ///","Lowlink Library":"// Lowlink(UndirectedGraph)\n// or use addEdge\n// must build()\n/// --- Lowlink Library {{{ ///\n\nstruct Lowlink {\n  struct Edge {\n    int to, idx;\n  };\n  int n;\n  int edgeSize = 0;\n  vector< vector< Edge > > g;\n  vector< int > ord, low;\n\n  vector< int > used;\n  vector< int > isBridge, isArticulation;\n  Lowlink(int n) : n(n), g(n), ord(n), low(n) {}\n  Lowlink(vector< vector< int > > ig) : n(ig.size()), g(n), ord(n), low(n) {\n    for(int from = 0; from < n; from++)\n      for(int to : ig[from])\n        if(from < to) addEdge(from, to);\n  }\n\n  void addEdge(int a, int b) {\n    g[a].emplace_back((Edge){b, edgeSize});\n    g[b].emplace_back((Edge){a, edgeSize});\n    edgeSize++;\n  }\n\n  void build() {\n    used.resize(n, 0);\n    isBridge.resize(edgeSize, 0);\n    isArticulation.resize(n, 0);\n\n    int k = 0;\n    dfs(0, -1, k);\n  }\n\nprivate:\n  void dfs(int i, int p, int &k) {\n    used[i] = 1;\n    ord[i] = low[i] = k++;\n    isArticulation[i] = 0;\n    int DFSTreeDegree = 0;\n    for(Edge edge : g[i]) {\n      int j = edge.to;\n      int idx = edge.idx;\n      if(j == p) continue;\n      if(!used[j]) {\n        // on dfs-tree\n        DFSTreeDegree++;\n        dfs(j, i, k);\n        low[i] = min(low[i], low[j]);\n        isBridge[idx] = ord[i] < low[j];\n        if(p != -1 && ord[i] <= low[j]) {\n          isArticulation[i] = 1;\n        }\n      } else {\n        low[i] = min(low[i], ord[j]);\n      }\n    }\n    if(p == -1 && DFSTreeDegree > 1) {\n      isArticulation[i] = 1;\n    }\n  }\n};\n\n/// }}}--- ///","MSTArborescence Library":"// require SCC Libary!\n// int MSTArborescence(WeightedDirectedGraph, int root)\n/// --- MSTArborescence Library {{{ ///\n\nll MSTArborescence(vector< vector< pair< int, int > > > &graph, int start,\n                   ll sum = 0) {\n  int n = graph.size();\n\n  vector< int > rev(n, -1);\n  vector< ll > weight(n, INF);\n  for(int idx = 0; i < n; i++) {\n    for(auto &e : graph[idx]) {\n      if(se(e) < weight[fi(e)]) {\n        weight[fi(e)] = se(e);\n        rev[fi(e)] = idx;\n      }\n    }\n  }\n\n  SCC scc(n);\n  for(int i = 0; i < n; i++) {\n    if(start == i) continue;\n    scc.addEdge(rev[i], i);\n    sum += weight[i];\n  }\n  vector< vector< int > > renew;\n  scc.decomposite(renew);\n  if(renew.size() == n) return sum;\n  vector< vector< pair< int, int > > > fixed(renew.size());\n  for(int i = 0; i < n; i++) {\n    for(P &e : graph[i]) {\n      if(scc[i] == scc[fi(e)]) continue;\n      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);\n    }\n  }\n  return MSTArborescence(fixed, scc[start], sum);\n}\n\n/// }}}--- ///","Strongly Connected Component":"// SCC(UnWeightedGraph)\n// must build(renew)\n/// --- Strongly Connected Component {{{ ///\n\nstruct SCC {\n  int n;\n  vector< vector< int > > g, rev;\n  vector< int > topo;\n  vector< int > used;\n  vector< int > comp;\n  SCC(int n) : n(n), g(n), rev(n) {}\n  SCC(vector< vector< int > > ig) : n(ig.size()), g(n), rev(n) {\n    for(int from = 0; from < n; from++)\n      for(int to : ig[from]) addEdge(from, to);\n  }\n  void addEdge(int a, int b) {\n    g[a].emplace_back(b);\n    rev[b].emplace_back(a);\n  }\n  int operator[](int i) { return comp[i]; }\n  void build(vector< vector< int > > &renew) {\n    used.resize(n, 0);\n    comp.resize(n, -1);\n    for(int i = 0; i < n; i++)\n      if(!used[i]) dfs1(i);\n    reverse(begin(topo), end(topo));\n    int k = 0;\n    for(int i : topo)\n      if(comp[i] == -1) dfs2(i, k++);\n\n    renew.resize(k);\n    set< pair< int, int > > connect;\n    for(int i = 0; i < n; i++) {\n      for(int j : g[i]) {\n        int x = comp[i], y = comp[j];\n        if(x == y) continue;\n        if(connect.count(make_pair(x, y))) continue;\n        connect.emplace(x, y);\n        renew[x].emplace_back(y);\n      }\n    }\n  }\n\nprivate:\n  void dfs1(int i) {\n    if(used[i]) return;\n    used[i] = 1;\n    for(int j : g[i]) dfs1(j);\n    topo.emplace_back(i);\n  }\n  void dfs2(int i, int num) {\n    if(comp[i] != -1) return;\n    comp[i] = num;\n    for(int j : rev[i]) dfs2(j, num);\n  }\n};\n\n/// }}}--- ///","FFT with long double Library":"/// --- FFT with long double Library {{{ ///\n\nusing C = complex< long double >;\nusing VC = vector< C >;\n\n// using FFT\nVC dft(VC a, bool inverse = false) {\n  constexpr long double PI = 3.14159265358979323;\n  int n = a.size();\n  if(n == 1) return a;\n  VC odd(n / 2), even(n / 2);\n  for(int i = 0; i < n / 2; i++) odd[i] = a[i * 2 + 1];\n  for(int i = 0; i < n / 2; i++) even[i] = a[i * 2];\n  odd = dft(odd);\n  even = dft(even);\n  C zeta = C(cos(2 * PI / n), sin(2 * PI / n));\n  if(inverse) zeta = C(1, 0) / zeta;\n  C powZeta = C(1, 0);\n  for(int _i = 0; _i < n; _i++) {\n    int i = _i;\n    if(inverse) i = (n - i) % n;\n    // powZeta = pow(zeta, i)\n    a[_i] = even[i % (n / 2)] + powZeta * odd[i % (n / 2)]; ////\n    if(inverse) a[_i] /= n;\n    powZeta *= zeta;\n  }\n  return a;\n}\n\n// convolution\nVC conv(VC a, VC b) {\n  int m = a.size();\n  int n = 1;\n  while(n < m) n <<= 1;\n  a.resize(n, C(0, 0));\n  b.resize(n, C(0, 0));\n  a = dft(a);\n  b = dft(b);\n  VC c(n);\n  for(int i = 0; i < n; i++) c[i] = a[i] * b[i];\n  return dft(c, true);\n}\n\n/// }}}--- ///","GaussJordan":"using Vec = vector< double >;\nusing Mat = vector< Vec >;\n/// --- GaussJordan {{{ ///\nVec gaussJordan(Mat mat, Vec v, double eps = 1e-9) {\n  int n = mat.size();\n  assert(n == (int) mat[0].size() && n == (int) v.size());\n  for(int i = 0; i < (int) v.size(); i++) {\n    mat[i].emplace_back(v[i]);\n  }\n  for(int i = 0; i < n; i++) {\n    int pivot = i;\n    for(int j = i + 1; j < n; j++) {\n      if(abs(mat[pivot][i] < abs(mat[j][i]))) pivot = j;\n    }\n    if(mat[pivot][i] < eps) return Vec();\n    swap(mat[i], mat[pivot]);\n    for(int j = i + 1; j <= n; j++) {\n      mat[i][j] /= mat[i][i];\n    }\n    for(int j = 0; j < n; j++)\n      if(j != i) {\n        for(int k = i + 1; k <= n; k++) {\n          mat[j][k] -= mat[j][i] * mat[i][k];\n        }\n      }\n  }\n  for(int i = 0; i < n; i++) v[i] = mat[i][n];\n  return v;\n}\n/// }}}--- ///","isPrime":"/// --- isPrime {{{ ///\n\nbool isPrime(int n) {\n  if(n < 2) return false;\n  for(int i = 2; i * i <= n; i++) {\n    if(n % i == 0) return false;\n  }\n  return true;\n}\n\n/// }}}--- ///","divisor":"// O(N^.5)\n/// --- divisor {{{ ///\nvector< ll > divisor(ll n) {\n  vector< ll > res;\n  for(ll i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      res.emplace_back(i);\n      if(i != n / i) res.emplace_back(n / i);\n    }\n  }\n  return res;\n}\n/// }}}--- ///","primeFactors":"// O(N^.5)\n/// --- primeFactors {{{ ///\nmap< ll, int > primeFactors(ll n) {\n  map< ll, int > res;\n  for(ll i = 2; i * i <= n; i++) {\n    while(n % i == 0) n /= i, res[i]++;\n  }\n  if(n != 1) res[n] = 1;\n  return res;\n}\n/// }}}--- ///","phi":"// O(N^.5)\n/// --- phi {{{ ///\nll phi(ll n) {\n  ll res = n;\n  for(ll i = 2; i * i <= n; i++) {\n    if(n % i == 0) {\n      res = res / i * (i - 1);\n      while(n % i == 0) n /= i;\n    }\n  }\n  if(n != 1) res = res / n * (n - 1);\n  return res;\n}\n/// }}}--- ///","phi2":"// O(N log log N)\n/// --- phi2 {{{ ///\nvector< int > phi2(int n) {\n  n++;\n  vector< int > euler(n);\n  for(int i = 0; i < n; i++) euler[i] = i;\n  for(int i = 2; i < n; i++) {\n    if(euler[i] == i) {\n      for(int j = i; j < n; j += i) euler[j] = euler[j] / i * (i - 1);\n    }\n  }\n  return euler;\n}\n/// }}}--- ///","primes":"/// --- primes {{{ ///\nvector< ll > primes(ll n) {\n  vector< ll > res;\n  for(ll i = 2; i * i <= n; i++) {\n    int isp = 1;\n    for(ll p : res) {\n      if(p * p > i) break;\n      if(i % p == 0) isp = 0;\n    }\n    if(isp) res.emplace_back(p);\n  }\n  return res;\n}\n/// }}}--- ///","math":"/// --- math {{{ ///\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll d;\n  return b == 0 ? (x = 1, y = 0, a)\n                : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n}\nll modinv(ll a, ll mod = 1e9 + 7) {\n  ll x = 0, y = 0;\n  extgcd(a, mod, x, y);\n  return (x + mod) % mod;\n}\nll modpow(ll a, ll b, ll mod = 1e9 + 7) {\n  ll r = 1;\n  a %= mod;\n  while(b) {\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\n/// }}}--- ///","givens":"using Vec = vector< double >;\nusing Mat = vector< Vec >;\n#define mkrot(x, y, c, s)           \\\n  {                                 \\\n    double r = sqrt(x * x + y * y); \\\n    c = x / r;                      \\\n    s = y / r;                      \\\n  }\n#define rot(x, y, c, s)        \\\n  {                            \\\n    double u = c * x + s * y;  \\\n    double v = -s * x + c * y; \\\n    x = u;                     \\\n    y = v;                     \\\n  }\nVec givens(Mat A, Vec b) {\n  const int n = b.size();\n  for(int i = 0; i < n; ++i)\n    for(int j = i + 1; j < n; ++j) {\n      double c, s;\n      mkrot(A[i][i], A[j][i], c, s);\n      rot(b[i], b[j], c, s);\n      for(int k = i; k < n; k++) rot(A[i][k], A[j][k], c, s);\n    }\n  for(int i = n - 1; i >= 0; --i) {\n    for(int j = i + 1; j < n; ++j) b[i] -= A[i][j] * b[j];\n    b[i] /= A[i][i];\n  }\n  return b;\n}","Matrix mult pow Library":"/// --- Matrix mult pow Library {{{ ///\n\ntemplate < class T >\nvector< vector< T > > mult(vector< vector< T > > a, vector< vector< T > > b) {\n  assert(a[0].size() == b.size());\n  vector< vector< T > > res(a.size(), vector< T >(b[0].size(), 0));\n  for(int i = 0; i < a.size(); i++) {\n    for(int j = 0; j < b[0].size(); j++) {\n      for(int k = 0; k < a[0].size(); k++) {\n        res[i][j] += a[i][k] * b[k][j];\n      }\n    }\n  }\n}\n\ntemplate < class T >\nvector< vector< T > > pow(vector< vector< T > > a, ll k) {\n  vector< vector< T > > r(a.size(), vector< T >(a.size(), 0));\n  for(size_t i = 0; i < a.size(); i++) r[i][i] = T(1);\n  while(k) {\n    if(k & 1) r = mult(r, a);\n    a = mult(a, a);\n    k >>= 1;\n  }\n  return r;\n}\n\n/// }}}--- ///\n\nusing Vec = vector< ll >;\nusing Mat = vector< Vec >;","moebius":"// O(N^.5)\nunordered_map< ll, int > moebius(ll n) {\n  unordered_map< ll, int > res;\n  vector< ll > primes;\n  for(ll i = 2; i * i <= n; i++) {\n    if(n % i == 0) primes.emplace_back(i);\n  }\n  if(n != 1) primes.emplace_back(n);\n  int m = primes.size();\n  for(int i = 0; i < (1 << m); i++) {\n    int mu = 1;\n    ll num = 1;\n    for(int j = 0; j < m; j++)\n      if(i & (1 << j)) {\n        mu *= -1;\n        num *= primes[j];\n      }\n    res[num] = mu;\n  }\n  return res;\n}","Monoid, M_act examples":"/// --- Monoid, M_act examples {{{ ///\n\n/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///\n\n// MinAdd m + x\n// MinSet m\n// SumAdd m * n + x\n// SumSet m * n\n\nstruct RangeMinAdd {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll, const X &x) { return m + x; }\n};\n\nstruct RangeMinSet {\n  using M = ll;\n  using X = RangeMin::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll, const X &) { return m; }\n};\n\nstruct RangeSumAdd {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, ll, ll n, const X &x) { return m * n + x; }\n};\n\nstruct RangeSumSet {\n  using M = ll;\n  using X = RangeSum::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return numeric_limits< M >::min(); }\n  static X actInto(const M &m, ll, ll n, const X &) { return m * n; }\n};\n\n/// }}}--- ///","Monoid examples":"/// --- Monoid examples {{{ ///\n\nstruct Nothing {\n  using T = char;\n  using M = char;\n  static constexpr T op(const T &, const T &) { return 0; }\n  static constexpr T identity() { return 0; }\n  template < class X >\n  static constexpr X actInto(const M &, ll, ll, const X &x) {\n    return x;\n  }\n};\n\nstruct RangeMin {\n  using T = ll;\n  static T op(const T &a, const T &b) { return min(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::max(); }\n};\n\nstruct RangeMax {\n  using T = ll;\n  static T op(const T &a, const T &b) { return max(a, b); }\n  static constexpr T identity() { return numeric_limits< T >::min(); }\n};\n\nstruct RangeSum {\n  using T = ll;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\n\n/// }}}--- ///","Montgomery Library":"/// --- Montgomery Library {{{ ///\n\ntemplate < int mod = (int) 1e9 + 7 >\nstruct Montgomery {\n  int modlen = 64 - __builtin_clzll(mod);\n  ll r2 = (1ll << (modlen * 2)) % mod;\n  ll mask = (1 << modlen) - 1;\n  ll nr;\n  Montgomery() {\n    nr = 0;\n    int t = 0;\n    int vi = 1;\n    for(int i = 0; i < modlen; i++) {\n      if((t & 1) == 0) {\n        t += mod;\n        nr += vi;\n      }\n      t >>= 1;\n      vi <<= 1;\n    }\n  }\n  ll reduction(ll t) {\n    ll c = t * nr;\n    c &= mask;\n    c *= mod;\n    c += t;\n    c >>= modlen;\n    if(c >= mod) c -= mod;\n    return c;\n  }\n  // maybe, a * b must not be overflow\n  inline ll mul(ll a, ll b) { return reduction(reduction(a * b) * r2); }\n  ll pow(ll a, ll b) {\n    ll p = reduction(a * r2);\n    ll x = reduction(r2);\n    while(b) {\n      if(b & 1) x = reduction(x * p);\n      p = reduction(p * p);\n      b >>= 1;\n    }\n    return reduction(x);\n  }\n};\n\n/// }}}--- ///\n\nMontgomery<> montgomery;","NTT Library":"// require math library\n/// --- NTT Library {{{ ///\nstruct NTT {\n  ll mod, primitive;\n  NTT() {}\n  NTT(ll mod, ll primitive) : mod(mod), primitive(primitive) {}\n  vector< ll > fft(vector< ll > a, bool inv = 0) {\n    int n = a.size();\n    int h = 32 - __builtin_clz(n);\n    h--;\n    // bitの反転\n    for(int i = 0; i < n; i++) {\n      int j = 0;\n      for(int k = 0; k < h; k++) j |= (i >> k & 1) << (h - 1 - k);\n      if(i < j) swap(a[i], a[j]);\n    }\n    // i : 今考えている多項式の次数 / 2\n    for(int i = 1; i < n; i *= 2) {\n      ll zeta = modpow(primitive, (mod - 1) / (i * 2), mod);\n      if(inv) zeta = modinv(zeta, mod);\n      ll tmp = 1;\n      // j : 指数\n      for(int j = 0; j < i; j++) {\n        // k : 何個目の多項式か\n        for(int k = 0; k < n; k += i * 2) {\n          ll s = a[k + j + 0];\n          ll t = a[k + j + i] * tmp % mod;\n          a[k + j + 0] = (s + t) % mod;\n          a[k + j + i] = (s - t) % mod;\n        }\n        tmp = tmp * zeta % mod;\n      }\n    }\n    int invn = modinv(n, mod);\n    if(inv)\n      for(int i = 0; i < n; i++) a[i] = a[i] * invn % mod;\n    for(int i = 0; i < n; i++) a[i] = (a[i] + mod) % mod;\n    return a;\n  }\n  template < typename T >\n  vector< ll > conv(vector< T > aa, vector< T > bb) {\n    int deg = aa.size() + bb.size();\n    int n = 1;\n    while(n < deg) n <<= 1;\n    vector< ll > a(n), b(n);\n    for(int i = 0; i < (int) aa.size(); i++) a[i] = aa[i] % mod;\n    for(int i = 0; i < (int) bb.size(); i++) b[i] = bb[i] % mod;\n    a = fft(a);\n    b = fft(b);\n    vector< ll > c(n);\n    for(int i = 0; i < n; i++) c[i] = a[i] * b[i] % mod;\n    return fft(c, 1);\n  }\n};\n/// }}}--- ///\n\nvector< NTT > ntts{\n    NTT((1 << 24) * 73 + 1, 3),\n    NTT((1 << 21) * 3 * 7 * 23 + 1, 5),\n    NTT((1 << 25) * 5 + 1, 3),\n    NTT((1 << 26) * 7 + 1, 3),\n    NTT((1 << 21) * 3 * 3 * 7 * 7 + 1, 5),\n};\n\n/// --- Garner Library {{{ ///\nll garner(vector< int > n, vector< int > mods, ll mod) {\n  n.emplace_back(0);\n  mods.emplace_back(mod);\n  vector< ll > coeffs(n.size(), 1); // v_i の係数\n  // v_i の項より後ろの項の和,答え mod mods[i]\n  vector< ll > constants(n.size(), 0);\n  for(size_t i = 0; i < n.size(); i++) {\n    // coeffs[i] * v_i + constants[i] == n[i] (mod mods[i]) を解く\n    ll v = ll(n[i] - constants[i]) * modinv(coeffs[i], mods[i]) % mods[i];\n    if(v < 0) v += mods[i];\n    for(size_t j = i + 1; j < n.size(); j++) {\n      // coeffs[j] is (mod j)\n      (constants[j] += coeffs[j] * v) %= mods[j];\n      (coeffs[j] *= mods[i]) %= mods[j];\n    }\n  }\n  return constants.back();\n}\n/// }}}--- ///\n\ntemplate < class T >\n// convolution with NTT {{{\nvector< ll > conv(vector< T > a, vector< T > b, int use = 1, ll mod = 1e9 + 7) {\n  vector< vector< ll > > cs;\n  auto nlist = ntts;\n  nlist.resize(use);\n  for(auto ntt : nlist) {\n    cs.emplace_back(ntt.conv(a, b));\n  }\n  if(use == 1) return cs[0];\n  int n = cs[0].size();\n  vector< ll > c(n);\n  for(int i = 0; i < n; i++) {\n    vector< ll > vals(use), mods(use);\n    for(int j = 0; j < use; j++) {\n      vals[j] = cs[j][i];\n      mods[j] = nlist[j].mod;\n    }\n    c[i] = garner(vals, mods, mod);\n  }\n  return c;\n}\n// }}}","Convex Hull Trick Library":"// CHT(bool increasing, Compare comp);\n// increasing : is query monotonic-increasing ?\n// comp : rhs is better\n// add(pair<T, T> line) : add deacrinsgly!!\n/// --- Convex Hull Trick Library {{{ ///\n\nstruct CHT {\n  using Line = pair< ll, ll >;\n  vector< Line > lines;\n  bool increasing;\n  function< bool(ll, ll) > comp;\n  CHT(bool increasing = false, function< bool(ll, ll) > comp =\n                                   [&](ll lhs, ll rhs) { return lhs >= rhs; })\n      : increasing(increasing), comp(comp) {}\n  // is l2 unnecessary ?\n  bool check(Line l1, Line l2, Line l3) {\n    return comp((l1.second - l2.second) * (l3.first - l2.first),\n                (l3.second - l2.second) * (l1.first - l2.first));\n  }\n  ll f(int i, ll x) { return lines[i].first * x + lines[i].second; }\n  // add decreasingly\n  void add(ll a, ll b) { add(Line(a, b)); }\n  void add(Line line) {\n    while((int) lines.size() >= 2 &&\n          check(lines[lines.size() - 2], lines.back(), line))\n      lines.pop_back();\n    lines.emplace_back(line);\n  }\n  ll query(ll x) {\n    if(increasing) {\n      static int head = 0;\n      while((int) lines.size() - 1 > head && comp(f(head, x), f(head + 1, x)))\n        head++;\n      return f(head, x);\n    } else {\n      int low = -1, high = lines.size() - 1;\n      while(high - low > 1) {\n        int mid = (low + high) >> 1;\n        (comp(f(mid, x), f(mid + 1, x)) ? low : high) = mid;\n      }\n      return f(high, x);\n    }\n  }\n};\n\n/// }}}--- ///","Dynamic Convex Hull Trick Library":"/// --- Dynamic Convex Hull Trick Library {{{ ///\n\nstruct DynamicCHT {\n  static const ll INF = numeric_limits< ll >::max();\n  DynamicCHT() {\n    // sentinel\n    S.insert({L(INF, 0), L(-INF, 0)});\n    C.insert(cp(L(INF, 0), L(-INF, 0)));\n  }\n  // for debug\n  void print() {\n#ifdef DEBUG\n    cerr << \"S : \";\n    for(auto it : S) cerr << \"(\" << it.a << \",\" << it.b << \")\" << endl;\n    cerr << \"C : \";\n    for(auto it : C) cerr << \"(\" << it.n << \",\" << it.d << \")\" << endl;\n#endif\n  }\n  // |ab| < LLONG_MAX/4 ???\n  void add(ll a, ll b) {\n    const L p(a, b);\n    It pos = S.insert(p).first;\n    if(check(*it_m1(pos), p, *it_p1(pos))) {\n      // 直線(a,b)が不要\n      S.erase(pos);\n      return;\n    }\n    C.erase(cp(*it_m1(pos), *it_p1(pos)));\n    {\n      // 右方向の削除\n      It it = it_m1(pos);\n      while(it != S.begin() && check(*it_m1(it), *it, p)) --it;\n      C_erase(it, it_m1(pos));\n      S.erase(++it, pos);\n      pos = S.find(p);\n    }\n    {\n      // 左方向の削除\n      It it = it_p1(pos);\n      while(it_p1(it) != S.end() && check(p, *it, *it_p1(it))) ++it;\n      C_erase(++pos, it);\n      S.erase(pos, it);\n      pos = S.find(p);\n    }\n    C.insert(cp(*it_m1(pos), *pos));\n    C.insert(cp(*pos, *it_p1(pos)));\n  }\n  ll query(ll x) {\n    const L &p = (--C.lower_bound(CP(x, 1, L(0, 0))))->p;\n    return p.a * x + p.b;\n  }\n\nprivate:\n  template < class T >\n  T it_p1(T a) {\n    return ++a;\n  }\n  template < class T >\n  T it_m1(T a) {\n    return --a;\n  }\n  struct L {\n    ll a, b;\n    L(ll a, ll b) : a(a), b(b) {}\n    bool operator<(const L &rhs) const {\n      return a != rhs.a ? a > rhs.a : b < rhs.b;\n    }\n  };\n  struct CP {\n    ll n, d;\n    L p;\n    CP(ll _n, ll _d, const L &p) : n(_n), d(_d), p(p) {\n      if(d < 0) {\n        n *= -1;\n        d *= -1;\n      }\n    };\n    bool operator<(const CP &rhs) const {\n      if(n == INF || rhs.n == -INF) return 0;\n      if(n == -INF || rhs.n == INF) return 1;\n      return n * rhs.d < rhs.n * d;\n    }\n  };\n  set< L > S;\n  set< CP > C;\n\n  typedef set< L >::iterator It;\n\n  void C_erase(It a, It b) {\n    for(It it = a; it != b; ++it) C.erase(cp(*it, *it_p1(it)));\n  }\n  CP cp(const L &p1, const L &p2) {\n    if(p1.a == INF) return CP(-INF, 1, p2);\n    if(p2.a == -INF) return CP(INF, 1, p2);\n    return CP(p1.b - p2.b, p2.a - p1.a, p2);\n  }\n  bool check(const L &p1, const L &p2, const L &p3) {\n    if(p1.a == p2.a && p1.b <= p2.b) return 1;\n    if(p1.a == INF || p3.a == -INF) return 0;\n    return (p2.a - p1.a) * (p3.b - p2.b) >= (p2.b - p1.b) * (p3.a - p2.a);\n  }\n};\n\n/// }}}--- ///","XorShift128":"/// --- XorShift128 {{{ ///\nstruct XorShift128 {\n  using u32 = uint32_t;\n  u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n  XorShift128(u32 seed = 0) { z ^= seed; }\n  u32 operator()() {\n    u32 t = x ^ (x << 11);\n    x = y, y = z, z = w;\n    return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n  }\n};\n/// }}}--- ///","AhoCorasick Library":"// never fail to call build() !!\n// constructor()\n// add(string)\n// match(string, f)           : [left, right], f(int left, int right, int key)\n// next(node, char, f): Trie* : f(int len, int key)\n// in right-asc -> left-desc order\n/// --- AhoCorasick Library {{{ ///\n\nstruct AhoCorasick {\n  struct Trie {\n    unordered_map< char, Trie * > child;\n    int id;\n    Trie *failure = nullptr;\n    Trie *next = nullptr; // next failure that has the word\n    int word = -1;\n    Trie *add(char c) {\n      if(child.count(c)) {\n        return child[c];\n      } else {\n        return child[c] = new Trie;\n      }\n    }\n    Trie *go(char c) {\n      if(child.count(c)) {\n        return child[c];\n      } else {\n        if(failure == nullptr) { // only top can come here\n          return this;\n        } else {\n          return failure->go(c);\n        }\n      }\n    }\n  };\n  Trie *top = new Trie;\n  vector< string > dict;\n  void add(string word) {\n    Trie *now = top;\n    for(size_t i = 0; i < word.size(); i++) {\n      now = now->add(word[i]);\n    }\n    now->word = dict.size();\n    dict.emplace_back(word);\n  }\n  void build() {\n    queue< Trie * > q;\n    q.emplace(top);\n    while(q.size()) {\n      Trie *now = q.front();\n      q.pop();\n      for(pair< char, Trie * > ch : now->child) {\n        q.emplace(ch.second);\n        Trie *failure = ch.second->failure =\n            now == top ? top : now->failure->go(ch.first);\n        ch.second->next = failure->word >= 0 ? failure : failure->next;\n      }\n    }\n  }\n  Trie *next(Trie *now, char c,\n             const function< void(int, int) > &f = [](int, int) {}) {\n    now = now->go(c);\n    Trie *tmp = now;\n    while(tmp != nullptr && tmp != top) {\n      int word = tmp->word;\n      if(word >= 0) {\n        f(dict[word].size(), word);\n      }\n      tmp = tmp->next;\n    }\n    return now;\n  }\n  void match(string s,\n             const function< void(int, int, int) > &f = [](int, int, int) {}) {\n    Trie *now = top;\n    for(size_t i = 0; i < s.size(); i++) {\n      now = now->go(s[i]);\n      Trie *tmp = now;\n      while(tmp != nullptr && tmp != top) {\n        int word = tmp->word;\n        if(word >= 0) {\n          f(i - dict[word].size() + 1, i, word);\n        }\n        tmp = tmp->next;\n      }\n    }\n  }\n};\n\n/// }}}--- ///\n\nusing Trie = AhoCorasick::Trie;","mp":"// [i] = size of longest common suffix and prefix in s[0,i-1]\n// 瞬間最悪計算量 O(N)\n// 均し計算量 O(N)\nvector< int > MP(string s) {\n  int n = s.size();\n  vector< int > A(n + 1);\n  A[0] = -1;\n  int j = -1;\n  for(int i = 0; i < n; i++) {\n    while(j >= 0 && s[i] != s[j]) j = A[j];\n    A[i + 1] = ++j;\n  }\n  return A;\n}","kmp":"// [i] = size of longest common suffix and prefix in s[0,i-1]\n// 瞬間最悪計算量 O(log N)\n// 均し計算量 O(N)\nvector< int > KMP(string s) {\n  int n = s.size();\n  vector< int > kmp(n + 1), mp(n + 1);\n  kmp[0] = mp[0] = -1;\n  int j = -1;\n  for(int i = 0; i < n; i++) {\n    while(j >= 0 && s[i] != s[j]) j = kmp[j];\n    kmp[i + 1] = mp[i + 1] = ++j;\n    if(i + 1 < n && s[i + 1] == s[j]) kmp[i + 1] = kmp[j];\n  }\n  return mp;\n}","cycle":"// [i] = min cycle length in [0,i]\n// 最小周期長\n// NOTE : justである必要なし\nvector< int > cycle(string s) {\n  auto mp = MP(s);\n  vector< int > len(s.size());\n  for(int i = 0; i < (int) s.size(); i++) len[i] = i + 1 - mp[i + 1];\n  return len;\n}","LCP Array Library":"// require SA\n/// --- LCP Array Library {{{ ///\n\ntemplate < class S = SA<> >\nstruct LCP {\n  using T = typename S::T;\n  const int n;\n  const T &s;\n  vector< int > lcp;\n  int operator[](int i) const { return lcp[i]; }\n  LCP(const S &sa) : n(sa.n), s(sa.s), lcp(n - 1) {\n    int h = 0;\n    for(int i = 0; i < n; i++) {\n      if(h) h--;\n      if(sa.rnk[i] == 0) continue;\n      int j = sa[sa.rnk[i] - 1];\n      while(i + h < n && j + h < n && s[i + h] == s[j + h]) h++;\n      lcp[sa.rnk[i] - 1] = h;\n    }\n  }\n};\n\n/// }}}--- ///","manacher":"// [i] = max radius as a palindrome when [i] is center\n// NOTE : 偶数長ほしいなら'$'とか挿入してね\nvector< int > Manacher(string s) {\n  int n = s.size();\n  int i = 0, j = 0;\n  vector< int > R(n);\n  while(i < n) {\n    while(i - j >= 0 && i + j < n && s[i - j] == s[i + j]) ++j;\n    R[i] = j;\n    int k = 1;\n    while(i - k >= 0 && R[i - k] < j - k) R[i + k] = R[i - k], ++k;\n    i += k, j -= k;\n  }\n  return R;\n}","SA-IS":"/// --- SA-IS {{{ ///\n\ntemplate < class _T = string, class U = char, int K = 256 >\nstruct SA {\n  using T = _T;\n  const int n;\n  const T &s;\n  vector< int > rnk;\n  vector< int > sa;\n  int operator[](int i) const { return sa[i]; }\n  SA(const string &s) : n(s.size()), s(s), rnk(n) {\n    sa_is< T, U >(sa, s + U(0), K); // change if T != string\n    sa.erase(begin(sa));\n    for(int i = 0; i < n; i++) rnk[sa[i]] = i;\n  }\n  template < class V = string, class W = char >\n  void sa_is(vector< int > &sa, const V &s, int k) {\n    int n = s.size();\n    vector< int > S(n); // or L\n    //\n    S.back() = 1;\n    for(int i = n - 2; i >= 0; i--) {\n      if(s[i] < s[i + 1])\n        S[i] = 1;\n      else if(s[i] > s[i + 1])\n        S[i] = 0;\n      else\n        S[i] = S[i + 1];\n    }\n    //\n    vector< int > lms;\n    for(int i = 0; i < n; i++)\n      if(isLMS(S, i)) lms.emplace_back(i);\n    auto seed = lms;\n\n    vector< int > _sa;\n    inducedSort< V, W >(_sa, s, k, S, seed);\n\n    sa.resize(0);\n    for(auto el : _sa)\n      if(isLMS(S, el)) sa.emplace_back(el);\n\n    vector< int > nums(n, -1);\n    int num = 0;\n    nums[sa[0]] = 0;\n\n    for(int x = 0; x < (int) sa.size() - 1; x++) {\n      int i = sa[x], j = sa[x + 1];\n      int diff = 0;\n      for(int d = 0; d < n; d++) {\n        if(s[i + d] != s[j + d] || isLMS(S, i + d) != isLMS(S, j + d)) {\n          diff = 1;\n          break;\n        } else if(d && (isLMS(S, i + d) || isLMS(S, j + d)))\n          break;\n      }\n      if(diff) num++;\n      nums[j] = num;\n    }\n    auto _nums = nums;\n    nums.resize(0);\n    for(int el : _nums)\n      if(el != -1) nums.emplace_back(el);\n\n    if(num + 1 < (int) nums.size()) {\n      sa_is< vector< int >, int >(seed, nums, num + 1);\n    } else {\n      seed.resize(num + 1);\n      for(int i = 0; i < num + 1; i++) seed[nums[i]] = i;\n    }\n\n    for(int &el : seed) el = lms[el];\n\n    inducedSort< V, W >(sa, s, k, S, seed);\n  }\n  template < class V = string, class W = char >\n  void inducedSort(vector< int > &sa, const V &s, int k, const vector< int > &S,\n                   const vector< int > &lms) {\n    int n = s.size();\n    sa.resize(n), sa.assign(n, -1);\n    vector< int > bin(k + 1, 0);\n    for(W ch : s) bin[ch + 1]++;\n    int sum = 0;\n    for(int &el : bin) el = sum += el;\n    // step 1\n    vector< int > count(k);\n    for(auto it = rbegin(lms); it != rend(lms); ++it) {\n      int i = *it;\n      W ch = s[i];\n      sa[bin[ch + 1] - 1 - count[ch]] = i;\n      count[ch]++;\n    }\n    // step 2\n    count.assign(k, 0);\n    for(int i : sa) {\n      if(i == -1 || i == 0) continue;\n      if(S[i - 1]) continue;\n      W ch = s[i - 1];\n      sa[bin[ch] + count[ch]] = i - 1;\n      count[ch]++;\n    }\n    // step 3\n    count.assign(k, 0);\n    for(auto it = rbegin(sa); it != rend(sa); ++it) {\n      int i = *it;\n      if(i == -1 || i == 0) continue;\n      if(!S[i - 1]) continue;\n      W ch = s[i - 1];\n      sa[bin[ch + 1] - 1 - count[ch]] = i - 1;\n      count[ch]++;\n    }\n  }\n  inline bool isLMS(const vector< int > &S, int i) {\n    return i > 0 && !S[i - 1] && S[i];\n  }\n};\n\n/// }}}--- ///","Suffix Array with Manber & Myers":"/// --- Suffix Array with Manber & Myers {{{ ///\n\ntemplate < class _T = string >\nstruct SA {\n  using T = _T;\n  const int n;\n  const T &s;\n  vector< int > rnk;\n  vector< int > sa;\n  int operator[](int i) const { return sa[i]; }\n  SA(const T &s) : n(s.size()), s(s), rnk(n), sa(n) {\n    iota(begin(sa), end(sa), 0);\n    sort(begin(sa), end(sa), [&](int a, int b) { return s[a] < s[b]; });\n    for(int i = 0; i < n; i++) rnk[i] = s[i];\n    for(int i = 1; i < n; i <<= 1) {\n      auto comp = [&](int a, int b) {\n        if(rnk[a] != rnk[b]) return rnk[a] < rnk[b];\n        a = a + i < n ? rnk[a + i] : -1;\n        b = b + i < n ? rnk[b + i] : -1;\n        return a < b;\n      };\n      sort(begin(sa), end(sa), comp);\n      auto tmp = rnk;\n      tmp[sa[0]] = 0;\n      for(int j = 1; j < n; j++)\n        tmp[sa[j]] = tmp[sa[j - 1]] + comp(sa[j - 1], sa[j]); ///\n      rnk = tmp;\n    }\n  }\n};\n\n/// }}}--- ///","zalgorithm":"// size of longest common prefix between s and s[i, -1]\nvector< int > Zalgorithm(string s) {\n  int n = s.size();\n  vector< int > Z(n);\n  Z[0] = n;\n  int i = 1, j = 0;\n  while(i < n) {\n    while(i + j < n && s[j] == s[i + j]) ++j;\n    Z[i] = j;\n    if(j == 0) {\n      ++i;\n      continue;\n    }\n    int k = 1;\n    while(i + k < n && Z[k] < j - k) Z[i + k] = Z[k], ++k;\n    i += k, j -= k;\n  }\n  return Z;\n}"}